;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2016 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : adaptive-noise.lisp
;;; Version     : 2.0a2
;;; 
;;; Description : Change the activation equation for declarative memory so that
;;;             : the instantaneous noise (that generated by :ans) is not a
;;;             : separate factor, but gets added to the base-level component 
;;;             : before the log is taken.
;;; 
;;; Bugs        : 
;;;
;;; To do       : 
;;; 
;;; ----- History -----
;;; 2016.08.25 Dan [1.0a1]
;;;             : * Initial creation.
;;; 2018.08.21 Dan [2.0a1]
;;;             : * Updated to work safely with 7.6+ by adding a lock for all of
;;;             :   the internals of the module.  Use a recursive lock since the
;;;             :   param function calls sgp with parameters that the module is
;;;             :   monitoring, and just lock around everything for simplicity.
;;; 2020.01.10 Dan [2.0a2]
;;;             : * Removed the #' and lambdas from the module interface.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;; Loading this file adds a new module called adaptive-noise which provides a
;;; parameter called :uan which if set to t alters the way activations are 
;;; computed.  This is being provided to allow for testing this alternative 
;;; approach to noise in activation values when base level learning is being used.
;;; The effect of this change is to decrease the effect of the noise as the 
;;; practice of an item increases.
;;;
;;;
;;; The file can be loaded automatically by adding this to a model file:
;;; (require-extra "adaptive-noise")
;;;
;;; When enabled the equations for activations changes from:
;;;
;;; B + S + P + n1 + n2
;;;
;;; where B = base-level activation, S = spreading activation, P = partial
;;; matching penalty, n1 = instantaneous noise (:ans), and n2 = permanent noise
;;; (:pas) to this:
;;;
;;; B' + S + P + n2
;;;
;;; where B' is now 
;;; 
;;;            n
;;; B' = ln( [sum t[i]^-d)] + exp(n1))
;;;           i=1
;;; 
;;; (or the appropriate approximation when optimized learning is enabled).
;;;
;;; The change is to move the instantaneous noise inside the log with the 
;;; base level computation.
;;;
;;; The noise needs to be exponentiated to avoid the possibility of a negative
;;; value inside the log calculation.  That effectively makes it a log-logistic
;;; noise distribution instead of just a logistic noise distribution.  That means
;;; the final activation will always be greater than just the base-level unlike
;;; the standard activation calculation.  That means that the retrieval threshold
;;; and latency factor parameters will need to be adjusted for a model relative
;;; to what they would be if the model were to be using the standard calculation,
;;; but since activations don't have a natural zero it is effectively just shifting
;;; the scale.  The median value of the noise component will be 1, and the mean
;;; is only defined if :ans < 1 in which case it is: 
;;;
;;;    pi * :ans
;;;   -----------
;;;  sin (pi * :ans)
;;;
;;; If base-level learning is not enabled then enabling this change does not 
;;; affect the system since the base-level component will be equal to the noise
;;; component that would be added without this change.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;;
;;; 
;;; To use the adaptive noise calculation for activations set the :uan (use 
;;; adaptive noise) parameter to t.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;; 
;;; This code works by setting the :bl-hook and :noise-hook parameters of the 
;;; declarative module to override the default mechanisms without having to
;;; modify the code for the declarative module directly.
;;;
;;; If this mechanism is being used and those parameters are changed explicitly
;;; by the model or other code then a warning will be printed to indicate that
;;; it may no longer function as expected.
;;;
;;; It's provided as a module so that it can provide the new parameter and 
;;; operate such that when it isn't being used it doesn't affect the normal
;;; calculations at all.  That also makes it easy to monitor the declarative 
;;; parameters to record what it needs and to check for changes to the hooks.
;;; However, there is an efficiency issue since each chunk's activation 
;;; calculation requires getting the current model's instance of the module to
;;; perform the calculation.
;;;
;;; It does make some assumptions about the declarative module's operation so
;;; that it can continue to produce a readable activation trace, but the saved
;;; trace data printed with print-activation-trace (and other commands that
;;; rely on the :sact data) will not show the trace the same as it appears when
;;; printed 'live' with :uan enabled.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)

(written-for-act-r-version "7.15" "adaptive-noise extension")

(defstruct adaptive-noise-module act uan bll blc ans ol act-scale (lock (bt:make-recursive-lock "adaptive-noise")))

(defun an-logistic-noise (s)
  (if (numberp s)
      (exp (act-r-noise s))
    0))

(defun compute-adaptive-noise-references (module n references creation-time minus-decay)
  "Computes generalized decay formula from number and list of references,
   creation time and minus the decay rate with the associative noise included in the log."
  
  (when (dm-act-level (adaptive-noise-module-act module) 'medium)
    (model-output "Computing base-level from ~d references (~{~/print-time-in-seconds/~^ ~})" n references)
    (model-output "  creation time: ~/print-time-in-seconds/ decay: ~f  Optimized-learning: ~s" creation-time (- minus-decay) (adaptive-noise-module-ol module)))
  
  (let ((value 0.0)
        (last-reference 0))
    (when references
      (dolist (reference references)
        (incf value (expt-coerced (max 50 (- (mp-time-ms) reference)) minus-decay))
        (setf last-reference reference)))
    
    (if (adaptive-noise-module-ol module)
        (let ((denominator (+ 1.0 minus-decay)))
          (if (numberp (adaptive-noise-module-ol module))
              (progn
                (when (> n (adaptive-noise-module-ol module))
                  (when (or (< (mp-time-ms) creation-time)
                            (< (mp-time-ms) last-reference))
                    (print-warning "Activation calculation problem because time has moved backwards.  Assuming a 0 time delay to avoid calculation error."))
                  (incf value (/ (* (- n (adaptive-noise-module-ol module))
                                    (- (expt-coerced (max 0 (- (mp-time-ms) creation-time)) denominator)
                                       (expt-coerced (max 0 (- (mp-time-ms) last-reference)) denominator)))
                                 (* (max 50 (- last-reference creation-time)) denominator))))
                
                (let ((noise (an-logistic-noise (adaptive-noise-module-ans module))))
                  (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                    (model-output "Adding adaptive noise: ~f" noise))
                  (setf value (log (+ (* (adaptive-noise-module-act-scale module) value) 
                                      noise)))))
            
            (let ((result (/ (* n (expt-coerced (max .05 (ms->seconds (- (mp-time-ms) creation-time))) minus-decay))
                             denominator))
                  (noise (an-logistic-noise (adaptive-noise-module-ans module))))
              (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                (model-output "Adding adaptive noise: ~f" noise))
              
              (setf value (log (+ result
                                  noise))))))
      (let ((noise (an-logistic-noise (adaptive-noise-module-ans module))))
         (when (dm-act-level (adaptive-noise-module-act module) 'medium)
           (model-output "Adding adaptive noise: ~f" noise))
         
         (setf value (log (+ (* (adaptive-noise-module-act-scale module) value) 
                             noise)))))
    value))

(defun adaptive-noise-base-level-activation (chunk)
  (let ((module (get-module adaptive-noise)))
    ;; just set the lock before performing the computation
    (bt:with-recursive-lock-held ((adaptive-noise-module-lock module))
      (cond ((adaptive-noise-module-bll module)
             (+ (progn
                  (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                    (model-output "Starting with blc: ~f" (adaptive-noise-module-blc module)))
                  
                  (adaptive-noise-module-blc module))
                
                (cond ((zerop (chunk-reference-count chunk))
                       (model-warning "Cannot compute base-level for a chunk with no references.")
                       -999999.0)
                      (t ;; just use the ACT-R 5 function basically as is for now
                       (compute-adaptive-noise-references module (chunk-reference-count chunk)
                                                          (chunk-reference-list chunk) (chunk-creation-time chunk)
                                                          (- (adaptive-noise-module-bll module)))))))
            (t ;; bll nil
             
             (+ ;; need to add regular noise here since it's turned off in the
              ;; noise calculation
              (if (chunk-base-level chunk)
                  (progn
                    (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                      (model-output "User provided chunk base-level: ~f" (chunk-base-level chunk)))
                    (chunk-base-level chunk))
                (progn
                  (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                    (model-output "Starting with blc: ~f" (adaptive-noise-module-blc module)))
                  (adaptive-noise-module-blc module)))
              (let ((noise (if (numberp (adaptive-noise-module-ans module))
                               (act-r-noise (adaptive-noise-module-ans module))
                             0)))
                (when (dm-act-level (adaptive-noise-module-act module) 'medium)
                  (model-output "Adding non-adaptive noise without base-level learning: ~f" noise))
                noise)))))))


(defun only-permanent-noise (chunk)
  (let ((noise (chunk-permanent-noise chunk))
        (module (get-module adaptive-noise)))
    (bt:with-recursive-lock-held ((adaptive-noise-module-lock module))
      (when (dm-act-level (adaptive-noise-module-act module) 'medium)
        (model-output "Adding permanent noise ~f" noise))
      noise)))




(defun adaptive-noise-params (module param)
  (bt:with-recursive-lock-held ((adaptive-noise-module-lock module))
  (if (consp param)
      (case (car param)
        (:act (setf (adaptive-noise-module-act module) (cdr param)))
        (:ans (setf (adaptive-noise-module-ans module) (cdr param)))
        (:bll (setf (adaptive-noise-module-bll module) (cdr param))
              (when (cdr param)
                (setf (adaptive-noise-module-act-scale module) (expt 1/1000 (- (cdr param))))))
        (:blc (setf (adaptive-noise-module-blc module) (cdr param)))
        (:ol (setf (adaptive-noise-module-ol module) (cdr param)))
        (:uan 
         (cond ((and (null (adaptive-noise-module-uan module)) (cdr param))
                ;; Turning it on
                (setf (adaptive-noise-module-uan module) (cdr param))
                (let ((current (no-output (sgp :bl-hook :noise-hook))))
                  (awhen (first current)
                         (print-warning "The :bl-hook parameter is currently set to ~s but enabling the :uan parameter will replace that." it))
                  (awhen (second current)
                         (print-warning "The :noise-hook parameter is currently set to ~s but enabling the :uan parameter will replace that." it))
                  (sgp :bl-hook adaptive-noise-base-level-activation :noise-hook only-permanent-noise)))
               ((and (adaptive-noise-module-uan module) (null (cdr param)))
                ;; turning it off
                (setf (adaptive-noise-module-uan module) (cdr param))
                (let ((current (no-output (sgp :bl-hook :noise-hook))))
                  (if (eq (first current) 'adaptive-noise-base-level-activation)
                      (sgp :bl-hook nil)
                    (print-warning "The :bl-hook parameter is currently set to ~s which was not set by the adaptive noise extension and will be left alone when :uan is turned off." (first current)))
                  (if (eq (second current) 'only-permanent-noise)
                      (sgp :noise-hook nil)
                    (print-warning "The :noise-hook parameter is currently set to ~s which was not set by the adaptive noise extension and will be left alone when :uan is turned off." (second current)))
                  )
                )
               (t ;; it's the same as it was so just ignore
                ))
               (cdr param))
        (:bl-hook
         (when (and (adaptive-noise-module-uan module) (neq (cdr param) 'adaptive-noise-base-level-activation))
           ;; uan is enabled and a different hook function gets set
           (print-warning "The :bl-hook parameter is being changed to ~s while the adaptive noise extension is enabled which requires a different base-level hook function." (cdr param))))
        (:noise-hook
         (when (and (adaptive-noise-module-uan module) (neq (cdr param) 'only-permanent-noise))
           ;; uan is enabled and a different hook function gets set
           (print-warning "The :noise-hook parameter is being changed to ~s while the adaptive noise extension is enabled which requires a different noise hook function." (cdr param))))
        )
               
    (case (car param)
      (:uan (adaptive-noise-module-uan module))))))

(defun create-adaptive-noise (name)
  (declare (ignore name))
  (make-adaptive-noise-module))

(defun reset-adaptive-noise (mod)
  (bt:with-recursive-lock-held ((adaptive-noise-module-lock mod))
    (setf (adaptive-noise-module-uan mod) nil)))

(define-module-fct 'adaptive-noise nil
  (list
   (define-parameter :uan :valid-test 'tornil :default-value nil :warning "T or nil"
     :documentation "Use the adaptive noise extension for activations")
   (define-parameter :act :owner nil)
   (define-parameter :ans :owner nil)
   (define-parameter :bll :owner nil)
   (define-parameter :blc :owner nil)
   (define-parameter :ol :owner nil)
   (define-parameter :bl-hook :owner nil)
   (define-parameter :noise-hook :owner nil)
   )
  :documentation "Adaptive noise extension for Activation equation."
  :version "2.0a2"
  :params 'adaptive-noise-params
  :creation 'create-adaptive-noise
  
  ;; have to make sure that it's turned off prior to other 
  ;; parameters being changed because relying on :uan to get its
  ;; default doesn't work since no order guarantee
  :reset 'reset-adaptive-noise
  )


(provide "adaptive-noise")

#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
