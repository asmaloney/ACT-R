;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : scheduling.lisp
;;; Version     : 5.2
;;; 
;;; Description : Event creation and scheduling and schedule running functions.
;;; 
;;; Bugs        : [X] Need to fix/remove the update functions from the modules
;;;             :     because how they get called prevents one from scheduleing
;;;             :     events correctly during one (in particular the device 
;;;             :     device-update-attended-loc doesn't accept the time parameters
;;;             :     but just adding that is really just a hack).
;;;             : [ ] There isn't a way to delete an "after" event that was waiting
;;;             :     but then got scheduled since it's no longer the same event
;;;             :     in the queue.
;;;
;;; To do       : [ ] Finish documentation.
;;;             : [x] Add an equivalent to the real-time-slack-hook-fn in rpm.
;;;             : [ ] Consider a global randomize time flag and/or parameter to the
;;;             :     scheduling functions.
;;;             : [x] The break events and "stopping reason" trace don't go to
;;;             :     the output of all models but probably should so that if
;;;             :     the traces are split at the model level they all show it.
;;;             : [x] Run-full-time and run-until-time both still rely on the
;;;             :     time count in seconds to determine the "end" but that's
;;;             :     still got potential problems.

;;; 
;;; ----- History -----
;;;
;;; 2004.08.16 Dan
;;;             : Creation
;;; 2004.12.06 Dan
;;;             : Updated a warning message because I found it uninformative.
;;;             : Tried to fit things to 80 char line width.
;;; 2005.01.12 Dan
;;;             : Because the device is now a module it doesn't need to
;;;             : be handled specially in set-mp-clock.
;;; 2005.01.27 Dan
;;;             : * Modified run-one-event to use filter-output-events which
;;;             :   is now part of the printing module to determine if the
;;;             :   trace should be displayed.
;;; 2005.02.03 Dan
;;;             : * Removed the format call from the periodic action's details.
;;; 2005.02.14 Dan
;;;             : * Added the run-until-condition function.
;;; 2005.02.16 Dan
;;;             : * Some general cleanup and added the "stopping reason" output
;;;             :   to the run functions.
;;; 2005.02.22 Dan
;;;             : * Cleaned up the stopping reason output.
;;;             : * Fixed a bug in run-full-time by just making it use
;;;             :   run-until-time.
;;; 2005.02.25 Dan
;;;             : * Made run work more like pm-run in that if there are future
;;;             :   events it will work like run-full-time instead of just
;;;             :   stopping.
;;; 2005.02.28 Dan
;;;             : * Switched the stopping reason output from model-output to
;;;             :   meta-p-output (which I've put back into things) because
;;;             :   model-output doesn't work in a multi-model situation.
;;; 2005.04.20 Dan
;;;             : * Changed add-pre/post-event-hook so that fboundp doesn't
;;;             :   cause problems for Lispworks with lambdas.
;;; 2005.05.20 Dan
;;;             : * Fixed a bug in run-until-time (caused primarily when
;;;             :   run-full-time used) where a non-rounded time could cause
;;;             :   the system to get stuck.
;;; 2005.12.08 Dan
;;;             : * Fixed a bug in the output of the events generated by
;;;             :   schedule-periodic-event and periodic-action.
;;; 2006.01.25 Dan
;;;             : * Modifying all the "run" functions so that when they end 
;;;             :   a "run-terminated" event is passed to all the models if
;;;             :   it terminates other than due to a break.  This way, the
;;;             :   event hooks can detect when a run ends (either a break
;;;             :   event or an event with the run-terminated action) which
;;;             :   makes adding additional tracing and other tools easier.
;;; 2006.01.26 Dan
;;;             : * Added an optional parameter to the add-pre/post-event-hook
;;;             :   functions to suppress the warning if one adds a hook that's
;;;             :   already on the list.  It just returns nil in that case now.
;;;             :   This helps because the hook is at the meta-process level,
;;;             :   but one may have a module (at the model level) that needs
;;;             :   to add such a hook and not want to see the warning if there
;;;             :   are multiple models loaded and using it.
;;; 2006.01.30 Dan
;;;             : * Changed the run-terminated event to a maintenance event.
;;;             : * Added the keyword param :include-maintenance to the schedule-
;;;             :   after-* functions which indicates whether or not to include
;;;             :   maintenance events in those that can trigger it (it defaults
;;;             :   to nil).  This keeps things from getting scheduled after 
;;;             :   events that don't do anything for the model.
;;;             : * Added the schedule-maintenance-event-relative function to
;;;             :   be able to schedule maintenance events.  Could make it a
;;;             :   switch on the existing functions, but for now at least
;;;             :   I've decided to use a different function.
;;; 2006.02.24 Dan
;;;             : * Fixed a bug in run-until-time that caused it to not work
;;;             :   if there was more than one model defined.
;;; 2006.02.27 Dan [1.2]
;;;             : * Modified run-schd-queue and set-mp-clock so that they
;;;             :   now use the "real time" control functions that can be set
;;;             :   for the meta-process using mp-real-time-management.
;;; 2006.02.28 Dan
;;;             : * Added a schedule-maintenance-event function and changed
;;;             :   run-until-time to actually use it.
;;; 2006.03.03 Dan
;;;             : * Modified run-sched-queue to use the max-delta-time 
;;;             :   property set with mp-real-time-management.
;;;             :   New (non-maintenance) "dummy" events will be automatically 
;;;             :   generated to occur in any time slice that needs them. 
;;; 2006.03.08 Dan
;;;             : * Fixed a bug with schedule-break-after-module because it
;;;             :   didn't set the model for the event, so never matched up
;;;             :   with a new event to get scheduled.
;;;
;;; 2006.05.02 Dan
;;;             : * Noted an issue with the update function of modules and put
;;;             :   it under bugs above.
;;; 2006.07.13 Dan
;;;             : * Fixed a bug with run-until-time that caused it to jump
;;;             :   back in time if the end-time had already passed.
;;; 2006.07.14 Dan
;;;             : * Added another output to run-n-events to make it clearer
;;;             :   in the trace why it stopped - differentiate hitting the
;;;             :   event-count from just running out of events.
;;; 2006.07.18 Dan
;;;             : * Removed the schedule-maintenance-* functions and
;;;             :   replaced them with a keyword :maintenance t/nil
;;;             :   in the regular schedule-* functions.
;;;             : * Updated all references to schedule-maintenance-* with
;;;             :   the correct schedule-* function.
;;;             : * As a saftey check those maintenance functions now just
;;;             :   print a warning to let people know there was a change.
;;; 2006.07.20 Dan
;;;             : * Fixed a bug in schedule-periodic-event because it tried
;;;             :   to take the symbol-name of an interpreted function if that
;;;             :   was passed as the action.
;;;             : * Updated conditions-met because a break event doesn't have
;;;             :   a model so if it's waiting it'll never match to any specific
;;;             :   model so should instead match to any model.
;;;             : * Fixed update waiting-events because it didn't distinguish
;;;             :   between break events and normal events which caused a
;;;             :   problem for schedule-break-after-module.
;;; 2006.07.28 Dan
;;;             : * Fixed the warning in delete-event-hook.
;;; 2007.01.19 Dan
;;;             : * Fixed a bug in periodic-action because it had the same 
;;;             :   symbol-name issue as schedule-periodic-event did...
;;; 2007.04.16 Dan
;;;             : * Updated the version to 1.3.
;;;             : * Made the run-terminated action actually do something.  It
;;;             :   checks the :ncnar parameter and if true calls normalize-
;;;             :   chunk-names.  
;;; 2007.05.04 Dan
;;;             : * Added a general method for delete-event (specified the class
;;;             :   t) so that it doesn't throw an error if a bad value is
;;;             :   provided.
;;; 2007.07.13 Dan
;;;             : * Changed run-terminated so that when :ncnar is set to delete
;;;             :   it actually forces the chunk deletion and name uninterning.
;;; 2007.08.28 Dan
;;;             : * Added s and w options to run-step to show the event queue and
;;;             :   the waiting events during the stepping.
;;; 2007.10.31 Dan
;;;             : * Fixed a bug with the printing of break events in run-one-event -
;;;             :   if there was more than one model the event wasn't being output.
;;;             :   Now check for break events and use meta-p-output instead of 
;;;             :   model-output since a break doesn't have a model.
;;;             : * Changed the model name used for the terminating event output
;;;             :   to just '- so that it will always line up even if the longest
;;;             :   model name is only 1 character.
;;; 2007.11.30 Dan
;;;             : * Changed run-terminated to use awhen so it doesn't have to
;;;             :   call sgp twice (an expensive call).
;;; 2007.12.13 Dan
;;;             : * Fixed a bug in schedule-periodic-event because if it was
;;;             :   passed an action that wasn't a symbol the call to fboundp
;;;             :   for the details would break.
;;; 2008.05.02 Dan
;;;             : * Added another option to run-step (b) for showing the buffer
;;;             :   contents.
;;; 2008.10.23 Dan
;;;             : * Updated run-terminated to use the new flags for normalizing.
;;; 2008.10.28 Dan
;;;             : * Changed the model-output in run-one-event so that the 
;;;             :   event string isn't directly used as the format string to
;;;             :   avoid issues with tildes in the output.
;;; 2009.03.10 Dan [1.4]
;;;             : * Moved the code to check for sending module "updates" from
;;;             :   set-mp-clock to run-sched-queue.  This has two effects:
;;;             :   - Updates occur at the end of a time step now and not the
;;;             :     "top of the next one".
;;;             :   - It's safe to schedule events during an "update" (fixes
;;;             :     the bug listed under bugs).
;;; 2009.04.29 Dan
;;;             : * Added checks for recursive calls to run and now signal a
;;;             :   warning and just abort the later calls.
;;; 2009.12.04 Dan [1.5]
;;;             : * Updated the real-time running code to allow for a little
;;;             :   more responsiveness when a slack-hook is provided.  Events
;;;             :   can be scheduled during the slack-hook and they can jump
;;;             :   "back" in time if desired (which would require explicitly
;;;             :   scheduling them for that time since "now" has still already 
;;;             :   moved) which likely requires a custom clock as well (to
;;;             :   know when "now" is relative to where the event queue is).
;;;             : * In addition to that, if the allow-dynamics is also provided 
;;;             :   then events which were scheduled using one of the after
;;;             :   scheduling functions and are flagged as dynamic will be 
;;;             :   sensitive to those new events (or events that they schedule)
;;;             :   and may be moved back in time if appropriate (conflict-resolution 
;;;             :   is now scheduled as dynamic so it could move back).
;;;             : * It is important to note however that the scheduling code is
;;;             :   still not thread safe -- any asynchronous event scheduling
;;;             :   should occur in the slack-hook (or some other safe place) and 
;;;             :   be protected appropriately.
;;; 2010.09.02 Dan
;;;             : * Added a test to run-sched-queue to check if the end time is
;;;             :   greater than what can be represented accurately with the 
;;;             :   current floating point size of the time and warn if it should
;;;             :   be changed or there's nothing that can be done.
;;;             : * Changed the calls that set the time so that they go through
;;;             :   the proper coercion when things are changed.
;;; 2010.11.03 Dan
;;;             : * Changed all of the code to use time in milliseconds internally 
;;;             :   and convert to/from seconds where there's an interface with the
;;;             :   user since the API is for seconds.
;;;             : * Removed the floating point time check code since it's not 
;;;             :   necessary now, but may still be useful to know if the time
;;;             :   is "too big" in the future so still leaving it in comments
;;;             :   for potentially enabling again in the future.
;;; 2010.12.22 Dan
;;;             : * Took the toggle out of the run-sched-queue since the integer
;;;             :   time values won't have the same issues as floating point 
;;;             :   math and comparisons.
;;;             : * Added code to notify modules at the start of a run for all
;;;             :   the modules which have a run-notify function.
;;; 2011.01.11 Dan
;;;             : * Added code to notify modules at the end of a run too, and 
;;;             :   reorganized run-sched-queue a little to make sure the 
;;;             :   unwind-protect covers everything.
;;; 2011.01.14 Dan
;;;             : * Added the new command mp-running? to query whether the current
;;;             :   meta-process is currently running.
;;; 2011.02.04 Dan
;;;             : * Added visicon and buffer-status options to run-step.
;;; 2011.03.25 Dan
;;;             : * Took the API section out since it's out of date and I don't
;;;             :   want to update it with the new changes either...
;;;             : * Adjusted run-one-event so that dynamics clear their dynamic
;;;             :   flag before being output in the trace.
;;; 2011.03.29 Dan
;;;             : * Added the option of specifying time in milliseconds for all
;;;             :   of the scheduling commmands by specifying :time-in-ms t.
;;; 2011.04.25 Dan
;;;             : * Fixed a bug in schedule-event-relative introduced with the
;;;             :   :time-in-ms option.
;;;             : * Schedule-periodic-event and schedule-ee had the
;;;             :   same issue.
;;; 2011.04.28 Dan
;;;             : * Changed the schedule-maintenance-event* functions which aren't
;;;             :   used to avoid warnings at compile time.
;;;             : * Added some declaims to avoid compiler warnings about 
;;;             :   undefined functions.
;;; 2011.05.18 Dan 
;;;             : * Changed set-mp-clock and insert-queue-event to prevent time
;;;             :   from moving backwards.  The slack-hook for real time now
;;;             :   gets called with a second parameter which is the "next"
;;;             :   time in milliseconds.
;;; 2011.05.19 Dan
;;;             : * Added a declare to ignore next-time in real-time-slack.
;;; 2011.06.06 Dan
;;;             : * Changed the second parameter for the slack-hook to time in
;;;             :   seconds since all the "user" code should be working in seconds.
;;; 2011.06.07 Dan
;;;             : * Changed the real-time clock setting so that the real-time
;;;             :   clock function is called before the model time is checked 
;;;             :   so that a custom clock could schedule events that are "ahead"
;;;             :   of the next model event.
;;; 2012.01.27 Dan
;;;             : * Added an additional test to the scheduling functions so that
;;;             :   they reject actions which are macros since those will throw
;;;             :   an error at run time.
;;; 2012.08.08 Dan
;;;             : * Send all the notifications (start, stop, update, terminate)
;;;             :   to the models in order using meta-p-model-order instead of
;;;             :   maphashing over the model table for consistency.
;;; 2012.12.06 Dan
;;;             : * Changed run-sched-queue so that it returns the time in ms
;;;             :   and then convert that as needed in the "run" functions to
;;;             :   try and avoid other float issues with math on times.
;;; 2013.01.03 Dan
;;;             : * Use the meta-p-max-time-maintenance value when scheduling a
;;;             :   necessary time-delta event.
;;; 2013.01.04 Dan
;;;             : * Add cannot-define-model to run-sched-queue and send-run-terminated-events 
;;;             :   to avoid problems.
;;; 2014.02.21 Dan
;;;             : * Add a warning to the top of every run.
;;; 2014.07.17 Dan
;;;             : * Removed the warning.
;;; 2015.06.04 Dan
;;;             : * Use safe-seconds->ms for all the run and schedule time 
;;;             :   conversions.
;;; 2015.06.05 Dan
;;;             : * Finally adding a schedule-event-now function that does what
;;;             :   the name suggests to replace all the ...-relative 0 calls.
;;; 2015.06.09 Dan
;;;             : * The "clean up" run-full-time at the end of run now computes
;;;             :   the difference in ms and creates a rational to avoid floats.
;;; 2015.07.29 Dan [2.0]
;;;             : * Add the option of a precondition to an event.  It must be a
;;;             :   function and will be passed the same parameters as the action.
;;;             :   If an event has a precondition when it is the "next" event
;;;             :   which could occur the precondition is first tested.  If that
;;;             :   returns nil then the event is removed from the queue without
;;;             :   performing its action.  No output will be generated for the 
;;;             :   trace for an event with a failed precondition at this point,
;;;             :   and only maintenance events will be allowed to have preconditions
;;;             :   for now.  This is being added because the "unstuff" actions
;;;             :   for perceptual modules shouldn't advance the clock if there
;;;             :   isn't a chunk that needs to be unstuffed, but the module
;;;             :   can't remove the scheduled event because the buffer can be
;;;             :   modified by "anything" and thus it can't know until it needs
;;;             :   to try.
;;; 2015.08.25 Dan
;;;             : * Use the real-time-scale when updating the clock so that both
;;;             :   the clock and slack get the appropriate shift in time.
;;;             : * New system parameter :real-time-sleep-threshold which sets
;;;             :   the min time for sleeping in the default real time slack hook.
;;;             : * Run function's real-time parameter can be specified as a number
;;;             :   in addition to t.  If it is a number then that over rides
;;;             :   the current real-time-scale parameter.
;;; 2015.09.14 [3.0]
;;;             : * Not really a change to the code, but making the current
;;;             :   process of scheduling equal priority items after any existing
;;;             :   items of that priority the specified mechanism i.e. that's
;;;             :   what the docs say now so it shouldn't be changed in the
;;;             :   future.
;;; 2016.09.28 Dan
;;;             : * Removed all the setting of the :mp slot in the events.
;;; 2016.11.16 Dan [4.0]
;;;             : * Start to convert to using the central dispatcher for all
;;;             :   user commands.  At this point, the only one added is run,
;;;             :   and it still needs work because the trace/output situation
;;;             :   hasn't been worked out yet.
;;; 2016.11.17 Dan
;;;             : * Changed execute-act-r-command to evaluate-act-r-command.
;;; 2017.01.18 Dan
;;;             : * Removed the echo-act-r-output from run.  The assumption
;;;             :   now is that echoing is handled by the user.
;;;             : * Use handle-evaluate-results.
;;; 2017.01.27 Dan
;;;             : * Start to think about taking dispatch function names for
;;;             :   scheduling.  Right now just allow strings as the function 
;;;             :   value, but don't actually dispatch them correctly because
;;;             :   there are a bunch of issues to work out...
;;; 2017.01.30 Dan
;;;             : * Add-act-r-command call parameters reordered.
;;; 2017.02.02 Dan
;;;             : * Changed the real-time parameter for the run function from a
;;;             :   keyword parameter to an optional so it matches the signature
;;;             :   of the dispatchers function.
;;;             : * Added the run-full-time command as a dispatched command.
;;; 2017.02.09 Dan
;;;             : * Updated the call to run-full-time inside of run since real-time
;;;             :   is now optional not keyword.
;;; 2017.02.15 Dan
;;;             : * Allow all the scheduling commands to accept remote commands
;;;             :   for the actions and preconditions.
;;; 2017.02.20 Dan
;;;             : * Fixed a bug introduced with the last update.
;;; 2017.02.22 Dan
;;;             : * Adding a suite of "simple" scheduling commands which will
;;;             :   be available through the dispatcher.  The simple versions
;;;             :   will use optional parameters to match with the underlying
;;;             :   RPC protocol, not make available :destination since it can't
;;;             :   practically be sent remotely, always have medium output, 
;;;             :   always use milliseconds (since that's what gettime returns),
;;;             :   no alternate details, and no precondition.
;;;             :   For now, the simple event functions only return t or nil to
;;;             :   indicate success and thus can't be deleted, but there could
;;;             :   be an internal reference kept that maps something returnable,
;;;             :   like an int, to the actual event to allow that eventually.
;;; 2017.02.24 Dan
;;;             : * Allowing run-until-condition to accept a string that will call
;;;             :   a dispatch function.  That seems like an extremely bad way
;;;             :   to run things since it gets called for each event, but there's
;;;             :   a tutorial task that uses it so making it available...
;;; 2017.03.30 Dan
;;;             : * Replace meta-p-current-model usage with *current-act-r-model*.
;;; 2017.03.31 Dan
;;;             : * Mp-running? has been moved to the meta-process file and the
;;;             :   code which was setting the running slot now calls the function
;;;             :   set-mp-running and clear-mp-running in a macro that's used
;;;             :   in the run functions directly instead of run-sched-queue.
;;;             : * Also, run doesn't call run-full-time now because that would
;;;             :   be a problem with setting the running flag.
;;; 2017.06.02 Dan
;;;             : * Cleaned up some issues with the "current model" setting and
;;;             :   use current-model-struct instead of *current-act-r-model*
;;;             :   directly.
;;; 2017.06.22 Dan
;;;             : * Protected all access to meta-p-time, meta-p-model-order, and
;;;             :   meta-p-models.
;;; 2017.06.23 Dan
;;;             : * Protected meta-p-delayed and added the need-to-check-updates
;;;             :   function to avoid the need for that same or occurring in lots
;;;             :   of places.  Also protected meta-p-dynamics.
;;; 2017.06.28 Dan
;;;             : * Protecting the rest of the meta-p-* schedule slot access.
;;; 2017.06.30 Dan
;;;             : * Protecting the meta-p event hook slots.
;;;             : * Why did run and run-full-time go through the dispatcher but 
;;;             :   run-until-condition didn't?  For now not dispatching any, but
;;;             :   may need to revisit that.
;;;             : * Modified run-until-time and run-n-events to work remotely
;;;             :   and added the commands.
;;;             : * Added a schedule-simple-event-now local and remote.
;;;             : * Everything is thread safe except run-step (read and format
;;;             :   not feasible) and real-time-slack since the system parameter
;;;             :   :real-time-sleep-threshold isn't safe.
;;; 2017.06.14 Dan
;;;             : * Real-time-slack is now safe since system parameters are now
;;;             :   safe.  
;;;             : * Check the top-level-lock before running.
;;; 2017.08.24 Dan
;;;             : * Added signals for run-start and run-stop that can be monitored.
;;;             :   Should modules just monitor for those now instead of specifying
;;;             :   hook functions for those situations?
;;; 2017.08.28 Dan
;;;             : * Added a remote version of schedule-break-relative and updated
;;;             :   the doc string for the remote schedule-simple-event-relative.
;;;             : * Allow a pre-event-hook to force a break before executing the
;;;             :   event by returning the string "break".
;;; 2017.08.29 Dan
;;;             : * When the pre-event causes a break it needs to put the event
;;;             :   back on the queue!
;;; 2017.11.14 Dan
;;;             : * Fix an issue with run not printing the end reason when it 
;;;             :   stopped because the time limit was reached due to the need
;;;             :   for a dummy event because the next real event was beyond the
;;;             :   run time.
;;; 2017.11.20 Dan
;;;             : * Another fix for the previous issue because it printed the wrong 
;;;             :   time with that fix.  It should all be right now.
;;; 2017.12.06 Dan
;;;             : * Changed some of the doc strings for remote commands.
;;;             : * Added the schedule-simple-event-after-module remote command.
;;; 2017.12.08 Dan
;;;             : * Convert priorities from strings in the simple- functions.
;;; 2017.12.11 Dan
;;;             : * Also need to convert the module names in the simple functions.
;;; 2018.02.07 Dan [5.0]
;;;             : * Reworked all the event access to use the full struct since
;;;             :   the conc-name of evt- isn't used any more.
;;;             : * Simplified a lot of the scheduling code because the things
;;;             :   that touch the event queues have been abstracted and put
;;;             :   into functions in the meta-process code.
;;;             : * Return an id# for the events instead of the struct itself
;;;             :   so that it's more feasible to "use" them remotely.
;;;             : * Reworked the "running" code because as it was there were
;;;             :   some nasty race conditions now that events can come in
;;;             :   asynchronously -- in particular that it kept referring to
;;;             :   the first item in the event queue but gave up the lock 
;;;             :   between accesses to that value.
;;;             : * Also reworking how real-time works because it can't just 
;;;             :   spin when the current next-event has to wait since another
;;;             :   event that should happen during that wait time could show
;;;             :   up while it's waiting.
;;;             : * Real-time-slack now just yields instead of sleeping.
;;;             : * The real time slack fn is now passed current time and next
;;;             :   time and it can compute the delta if needed.
;;;             : * For the run-terminated-events don't actually put it on the
;;;             :   queue just run the created event directly.
;;;             : * Actually store the model structure in the event instead of
;;;             :   just the name.
;;;             : * Protect all access to event times and priorities with the
;;;             :   meta-p-schedule-lock.
;;; 2018.02.23 Dan
;;;             : * Depricate the "simple" scheduling functions and provide all
;;;             :   the parameters as optionals for external versions of all the
;;;             :   scheduling functions.
;;; 2018.02.28 Dan
;;;             : * Fixed some cut-and-paste bugs with the new external fcts.
;;; 2018.03.26 Dan
;;;             : * Pass the time to the run-until-condition condition function
;;;             :   since it's not safe to get the time at that point -- the lock
;;;             :   is held.
;;; 2018.05.10 Dan
;;;             : * Fixed run-sched-queue because it needed to use dispatch-
;;;             :   apply when running the time-function.
;;; 2018.05.11 Dan
;;;             : * Use the time-units-per-second value with an absolute clock.
;;; 2018.06.15 Dan
;;;             : * Remove the simple scheduling functions and use an options 
;;;             :   list to handle all keyword params.
;;;             : * Schedule-break-after-all changed from having one keyword
;;;             :   parameter to an optional.
;;; 2018.06.28 Dan
;;;             : * Moved the run-stop signal so it's always sent even if the
;;;             :   run terminates due to an error.
;;; 2018.07.11 Dan
;;;             : * Fix a typo with :priority being misspelled in the calls 
;;;             :   which process the external params for some actions.
;;; 2019.02.05 Dan
;;;             : * Adjustments because meta-p-models is now an alist.
;;; 2019.02.15 Dan
;;;             : * Added a switch that kills the trace output without having to
;;;             :   access the printing module or output filtering and it's 
;;;             :   associated with the system parameter - :high-performance.
;;; 2019.04.09 Dan
;;;             : * When creating events set the min and max slots instead of
;;;             :   priority when needed since priority is now always a number.
;;; 2019.05.22 Dan [5.1]
;;;             : * Added a run-until-action function that runs the system 
;;;             :   until after an event that has the provided action occurs.
;;; 2019.09.09 Dan
;;;             : * Adjusted calls to with-top-level lock to pass the string
;;;             :   that indicates why the lock is being held.
;;; 2020.06.02 Dan
;;;             : * Since run-one-event already sets the current model it can
;;;             :   skip filter-output-events and call the test directly now 
;;;             :   that it always sets a current model if possible, and filter-
;;;             :   test returns the current value of :v so that can be tested
;;;             :   to avoid the model-output call that needs to get the 
;;;             :   printing-module again.
;;; 2020.07.06 Dan [5.2]
;;;             : * Allow scheduling nil to just display the details. However,
;;;             :   if details aren't provided for a nil event it's going to 
;;;             :   show an event called internal-dummy-event-fn.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;;
;;;
;;; See reference-manual...
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;; 
;;; Keep the system as simple as I can.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)

(declaim (ftype (function () t) print-visicon))
(declaim (ftype (function () t) delete-chunks-after-run))
(declaim (ftype (function () t) update-chunks-at-all))
(declaim (ftype (function (t) t) filter-test))

(defvar *periodic-event-id-counter* 0)
(defvar *periodic-event-lock* (bt:make-lock "periodic-event"))

(defvar *allow-event-output* t)

(defun skip-unnecessary-events (mp)
  ; assume it's called with the lock held (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
  (do* ((cm (current-model-struct))
        (next-event (next-scheduled-event mp) (next-scheduled-event mp))
        (unnecessary (and next-event
                          (act-r-event-precondition next-event)
                          
                          (let ((*current-act-r-model* (if (act-r-event-model next-event)
                                                           (act-r-event-model next-event)
                                                         cm)))
                            (null (if (act-r-event-destination next-event)
                                      (dispatch-apply-list (act-r-event-precondition next-event) 
                                                      (append (list (get-module-fct (act-r-event-destination next-event))) 
                                                              (act-r-event-params next-event)))
                                    (dispatch-apply-list (act-r-event-precondition next-event) (act-r-event-params next-event))))))
                     (and next-event
                          (act-r-event-precondition next-event)
                          
                          (let ((*current-act-r-model* (if (act-r-event-model next-event)
                                                           (act-r-event-model next-event)
                                                         cm)))
                            (null (if (act-r-event-destination next-event)
                                      (dispatch-apply-list (act-r-event-precondition next-event) 
                                                      (append (list (get-module-fct (act-r-event-destination next-event))) 
                                                              (act-r-event-params next-event)))
                                    (dispatch-apply-list (act-r-event-precondition next-event) (act-r-event-params next-event))))))))
       ((not unnecessary) nil)
    (remove-scheduled-event mp next-event)))
              

(add-act-r-command "run-start" nil "Signal that the system is starting to run for monitoring. Params: run-start-time." nil)
(add-act-r-command "run-stop" nil "Signal that the system has stopped running for monitoring. Params: run-end-time." nil)

(defun run-sched-queue (mp stop-condition &key (real-time nil))
  "The internal function that steps through events sending them to be
    executed until a condtion is met"
  
  (unwind-protect 
      (let ((event-count 0)
            next-event
            evaluate
            next-time) 
        
        ;; Notify any modules which care that a new run has begun
        
        (dolist (model-name (bt:with-lock-held ((meta-p-models-lock mp)) (meta-p-model-order mp)))
          (let ((*current-act-r-model* (bt:with-lock-held ((meta-p-models-lock mp)) (cdr (assoc model-name (meta-p-models mp))))))
            (dolist (module (run-notify-modules))
              (run-notify-module module))))
        
        ;; Send the start signal and set the initial clock info
        
        (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
          (dispatch-apply "run-start" (meta-p-time mp))
          (setf (meta-p-break mp) nil)
          
          
          (setf (meta-p-start-time mp) (meta-p-time mp))
          
          (when real-time
            (setf (meta-p-start-real-time mp) 
              (dispatch-apply (meta-p-time-function mp)))
            
            (unless (numberp real-time)
              (setf real-time 1.0))))
        
        (loop
          
          (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
            
            (when (or (meta-p-break mp)
                      (skip-unnecessary-events mp) ;; always returns nil but need to do that now
                      (not (setf next-event (next-scheduled-event mp)))
                      (funcall stop-condition 
                               mp 
                               (act-r-event-mstime next-event)
                               event-count))
              (return))
            
            (set-mp-clock mp (act-r-event-mstime next-event) real-time)
            
            (setf evaluate (<= (act-r-event-mstime next-event) (meta-p-time mp)))
            (setf next-time (act-r-event-mstime next-event)))
          
          (if evaluate
              (let ((result (run-one-event mp next-event)))
                (if result
                    (incf event-count)
                  (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
                    (setf (meta-p-break mp) t))))
            (when real-time
              (dispatch-apply (meta-p-slack-function mp) (meta-p-time mp) next-time))))
        
        (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
          (remove-tagged-events mp 'dummy-event-function :key 'act-r-event-action :count nil :test 'eq)
          ;(dispatch-apply "run-stop" (meta-p-time mp))
          (values (- (meta-p-time mp) (meta-p-start-time mp)) event-count (meta-p-break mp))))
    
    (progn
      ;; generate a run-stop signal
      
      (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
          (dispatch-apply "run-stop" (meta-p-time mp)))

      ;; Notify any modules which care that a run has ended

      (dolist (model-name (bt:with-lock-held ((meta-p-models-lock mp)) (meta-p-model-order mp)))
        (let ((*current-act-r-model* (bt:with-lock-held ((meta-p-models-lock mp)) (cdr (assoc model-name (meta-p-models mp))))))
          (dolist (module (run-over-notify-modules))
            (run-over-notify-module module))))
      
      ;; instead of relying on the run functions to do this,
      ;; always do it here (even if there is a break) directly
      ;; instead of through an event.
      
      (dolist (model-name (bt:with-lock-held ((meta-p-models-lock mp)) (meta-p-model-order mp)))
        (let ((*current-act-r-model* (bt:with-lock-held ((meta-p-models-lock mp)) (cdr (assoc model-name (meta-p-models mp))))))
          (when (update-chunks-at-all)
            (normalize-chunk-names (delete-chunks-after-run))))))))



;;; run-one-event 
;;;

(defun run-one-event (mp next-event)
  (let ((*current-act-r-model* (act-r-event-model next-event))
          (break nil))
      
    (dolist (hook (bt:with-lock-held ((meta-p-event-hook-lock mp)) (meta-p-pre-events mp)))
      (let ((r (dispatch-apply hook (act-r-event-num next-event))))
        (when (and r (stringp r) (string-equal r "break"))
          (setf break t))))
    
    (when break  ;; don't remove the event and just return

      (meta-p-output (format-event (make-act-r-break-event :mp nil
                                                           :mstime (mp-time-ms)
                                                           :params nil
                                                           :details "forced by a pre-event hook")))
      (return-from run-one-event nil))
    
    ;; print the trace if needed
    
    (when (and *allow-event-output*
               (act-r-event-output next-event))
      
      (if *current-act-r-model*
          (multiple-value-bind (o v) (filter-test next-event)
            (when o
              (if (act-r-break-event-p next-event)
                  (meta-p-output (format-event next-event))
                (when v
                  (model-output "~a" (format-event next-event))))))
        
        ;; if we don't have a current-model just set it to the first one
        ;; in the meta-process to get parameter values (which would be
        ;; the same as default because default is only set when there's
        ;; one model defined...
          
        (let ((*current-act-r-model* (bt:with-lock-held ((meta-p-models-lock mp)) 
                                        (cdar (meta-p-models (current-mp))))))
          
          (multiple-value-bind (o v) (filter-test next-event)
            (when o
              (if (act-r-break-event-p next-event)
                  (meta-p-output (format-event next-event))
                (when v
                  (model-output "~a" (format-event next-event)))))))))
    
    ;; remove the event now so that it doesn't interfere with
    ;; events being scheduled while it's evaluated
    
    (remove-scheduled-event mp next-event)
    
    ;; evaluate the event
    
    (if (act-r-event-destination next-event)
        (dispatch-apply-list (act-r-event-action next-event) 
                             (append (list (get-module-fct
                                            (act-r-event-destination next-event))) 
                                     (act-r-event-params next-event)))
      (dispatch-apply-list (act-r-event-action next-event) (act-r-event-params next-event)))
    
    ;; call the post hooks -- the event is still available viay the id because it's temporarily 
    ;; stored by the meta-process with remove-scheduled-event
    
    (dolist (hook (bt:with-lock-held ((meta-p-event-hook-lock mp)) (meta-p-post-events mp)))
      (dispatch-apply hook (act-r-event-num next-event)))
    

    ;; return success
    
    t))

;;; set-mp-clock
;;;
;;; This function takes three parameters which are a meta-process, the next
;;; time as it stands now, and whether or not it's to run in real-time.
;;;

(defun set-mp-clock (mp time real-time)
  "Update the time of a meta-process"
  
  ;; assume this (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
    (if real-time
        (let ((actual-time (cond ((eq (meta-p-time-mode mp) 'absolute)
                                  (seconds->ms (/ (dispatch-apply (meta-p-time-function mp)) (meta-p-units-per-second mp))))
                                 (t ;; interval
                                  (+ (meta-p-start-time mp)
                                     (seconds->ms (* real-time (/ (- (dispatch-apply (meta-p-time-function mp)) (meta-p-start-real-time mp))
                                                                  (meta-p-units-per-second mp)))))))))
          (setf (meta-p-time mp) (min time actual-time)))
      (setf (meta-p-time mp) time)))
  


(defmacro indicate-running (&body body)
  `(when (set-mp-running "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (unwind-protect
         (with-top-level-lock "Unable to run the system." "a running command"
           ,@body)
       (clear-mp-running))))
         

(defun run (run-time &optional (real-time nil))
  (indicate-running
   (if (not (and (numberp run-time) (> run-time 0)))
       (print-warning "run-time must be a number greater than zero.")
     (let ((ms-time (safe-seconds->ms run-time 'run)))
       (flet ((test (mp next-time count)
                    (declare (ignore count))
                    (> (- next-time (meta-p-start-time mp)) ms-time)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             (let ((mp (current-mp)))
               
               (let ((mp-time (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))))
                 
                 (if (< time ms-time)
                     (if (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (null (meta-p-events mp)))
                         (meta-p-output (format-event (make-act-r-event 
                                                       :mstime mp-time
                                                       :module "------"
                                                       :model '-
                                                       :details 
                                                       "Stopped because no events left to process"
                                                       :output t
                                                       :mp nil)))
                       (progn
                         
                         (let ((msend-time (+ (- ms-time time) mp-time)))
                           (flet ((test (mp next-time count)
                                        (declare (ignore count) (ignore mp))
                                        (> next-time msend-time)))
                             
                             (if (current-model)
                                 (schedule-event msend-time 'dummy-event-function 
                                                 :maintenance t :priority :min 
                                                 :details "A dummy event to guarantee a run until time"
                                                 :time-in-ms t
                                                 :output nil)
                               (with-model-eval (first (mp-models)) ;; just pick the first one
                                 (schedule-event msend-time 'dummy-event-function 
                                                 :maintenance t 
                                                 :priority :min 
                                                 :details "A dummy event to guarantee a run until time"
                                                 :time-in-ms t
                                                 :output nil)))
                             
                             (run-sched-queue (current-mp) #'test :real-time real-time)))
                         (setf time ms-time)
                         (meta-p-output (format-event (make-act-r-event 
                                                       :mstime (mp-time-ms) 
                                                       :module "------"
                                                       :model '-
                                                       :details "Stopped because time limit reached"
                                                       :output t
                                                       :mp nil)))))
                   
                   (meta-p-output (format-event (make-act-r-event 
                                                 :mstime mp-time
                                                 :module "------"
                                                 :model '-
                                                 :details "Stopped because time limit reached"
                                                 :output t
                                                 :mp nil)))))))
           (values (ms->seconds time) events break)))))))


(add-act-r-command "run" 'run "Run the ACT-R scheduler for up to a specified amount of time. Params: time {real-time}." "Only one run allowed at a time")


(defun run-until-condition (condition &optional (real-time nil))
  (indicate-running
   (if (not (local-or-remote-function-p condition))
       (print-warning "condition must be a function or valid dispatch command string.")
     (multiple-value-bind (time events break)
         (run-sched-queue (current-mp) 
                          (if (stringp condition)
                              (lambda (mp next-time count)
                                (declare (ignore mp count))
                                (multiple-value-bind (success result) (evaluate-act-r-command condition next-time)
                                  (if success
                                      result
                                    (progn
                                      (print-warning "Run terminated because of Error:< ~s > evaluating condition." result)
                                      t))))
                            
                            (lambda (mp next-time count)
                              (declare (ignore mp count))
                              (funcall condition next-time)))
                          :real-time real-time)
       (unless break
         (let* ((mp (current-mp))
                (mp-time (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))))
           
           (if (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (null (meta-p-events mp)))
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime mp-time
                                             :module "------"
                                             :model '-
                                             :details "Stopped because no events to process"
                                             :output t
                                             :mp nil)))
             (meta-p-output (format-event (make-act-r-event 
                                           :mstime mp-time
                                           :module "------"
                                           :model '-
                                           :details "Stopped because condition is true"
                                           :output t
                                           :mp nil))))))
       (values (ms->seconds time) events break)))))

(add-act-r-command "run-until-condition" 'run-until-condition "Run the ACT-R scheduler until the provided function returns a non-nil value. Params: fct-or-cmd-string {real-time?}." "Only one run allowed at a time")


(defun run-until-action (action &optional (real-time nil))
  (indicate-running
   (if (not (or (symbolp action) (stringp action)))
       (print-warning "run-until-action must be given a name(symbol) or a string, but given ~s which is a ~s." action (type-of action))
     (let ((stop nil)
           (name (when (symbolp action) (symbol-name action))))
       (flet ((test-symbol (mp next-time count)
                           (declare (ignore next-time count))
                           (let* ((e (next-scheduled-event mp))
                                  (a (act-r-event-action e)))
                             (prog1
                                 stop
                               (unless stop
                                 (cond ((symbolp a)
                                        (setf stop (eq action a)))
                                       ((stringp a)
                                        (setf stop (string-equal name a))))))))
              
              (test-string (mp next-time count)
                           (declare (ignore next-time count))
                           (let* ((e (next-scheduled-event mp))
                                  (a (act-r-event-action e)))
                             (prog1
                                 stop
                               (unless stop
                                 (cond ((symbolp a)
                                        (setf stop (string-equal action (symbol-name a))))
                                       ((stringp a)
                                        (setf stop (string= action a)))))))))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) (if (symbolp action) #'test-symbol #'test-string) :real-time real-time)
           (unless break
             (if stop
                 (meta-p-output (format-event (make-act-r-event 
                                               :mstime (mp-time-ms) 
                                               :module "------"
                                               :model '-
                                               :details (format nil "Stopped because ~a action occurred" action)
                                               :output t
                                               :mp nil)))
               
               (meta-p-output (format-event (make-act-r-event 
                                               :mstime (mp-time-ms)
                                               :module "------"
                                               :model '-
                                               :details 
                                               "Stopped because no events left to process"
                                               :output t
                                               :mp nil)))))
                      
           (values (ms->seconds time) events break)))))))

(defun run-until-action-external (action &optional (real-time nil))
  (run-until-action (decode-string action) real-time))

(add-act-r-command "run-until-action" 'run-until-action-external "Run the ACT-R scheduler stopping after an event with the given action occurs. Params: 'action' {real-time}." "Only one run allowed at a time")

(defun run-full-time (run-time &optional (real-time nil))
  (indicate-running
   (if (not (and (numberp run-time) (> run-time 0)))
       (print-warning "run-time must be a number greater than zero.")
     
     (let* ((mp (current-mp))
            (msend-time (+ (safe-seconds->ms run-time 'run-full-time) (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp)))))
       (flet ((test (mp next-time count)
                    (declare (ignore count) (ignore mp))
                    (> next-time msend-time)))
         
         (if (current-model)
             (schedule-event msend-time 'dummy-event-function 
                             :maintenance t :priority :min 
                             :details "A dummy event to guarantee a run until time"
                             :time-in-ms t
                             :output nil)
           (with-model-eval (first (mp-models)) ;; just pick the first one
             (schedule-event msend-time 'dummy-event-function 
                             :maintenance t 
                             :priority :min 
                             :details "A dummy event to guarantee a run until time"
                             :time-in-ms t
                             :output nil)))
         
         (multiple-value-bind (time events break)
             (run-sched-queue mp #'test :real-time real-time)
           (unless break
             
             (meta-p-output (format-event (make-act-r-event 
                                           :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                           :module "------"
                                           :model '-
                                           :details "Stopped because time limit reached"
                                           :output t
                                           :mp nil))))
           (values (ms->seconds time) events break)))))))


(add-act-r-command "run-full-time" 'run-full-time "Run the ACT-R scheduler for the specified amount of time. Params: time {real-time}." "Only one run allowed at a time")
 

(defun dummy-event-function ())

(defun run-until-time (end-time &optional (real-time nil))
  (indicate-running
   (if (not (and (numberp end-time) (> end-time 0)))
       (print-warning "end-time must be a number greater than zero.")
     (let ((mp (current-mp))
           (ms-end-time (safe-seconds->ms end-time 'run-until-time)))
       
       (if (<= ms-end-time (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp)))
           (progn
             (meta-p-output (format-event (make-act-r-event 
                                           :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                           :module "------"
                                           :model '-
                                           :details "Stopped because end time already passed"
                                           :output t
                                           :mp nil)))
             (values 0 0 nil))
         (flet ((test (mp next-time count)
                      (declare (ignore count) (ignore mp))
                      (> next-time ms-end-time)))
           
           (if (current-model)
               (schedule-event ms-end-time 'dummy-event-function 
                               :maintenance t :priority :min 
                               :details "A dummy event to guarantee a run until time"
                               :time-in-ms t
                               :output nil)
             (with-model-eval (first (mp-models)) ;; just pick the first one
               (schedule-event ms-end-time 'dummy-event-function 
                               :maintenance t 
                               :priority :min 
                               :details "A dummy event to guarantee a run until time"
                               :time-in-ms t
                               :output nil)))
           
           (multiple-value-bind (time events break)
               (run-sched-queue mp #'test :real-time real-time)
             (unless break
               
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because time limit reached"
                                             :output t
                                             :mp nil))))
             (values (ms->seconds time) events break))))))))

(add-act-r-command "run-until-time" 'run-until-time "Run the ACT-R scheduler up to the indicated time. Params: end-time {real-time}." "Only one run allowed at a time")


(defun run-n-events (event-count &optional (real-time nil))
  (indicate-running
   (if (not (and (numberp event-count) (> event-count 0)))
       (print-warning "event-count must be a number greater than zero.")
     (flet ((test (mp next-time count)
                  (declare (ignore next-time) (ignore mp))
                  (= count event-count)))
       (let ((mp (current-mp)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             
             
             (if (< events event-count)
                 (meta-p-output (format-event (make-act-r-event 
                                               :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                               :module "------"
                                               :model '-
                                               :details "Stopped because no events to process"
                                               :output t
                                               :mp nil)))   
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because event limit reached"
                                             :output t
                                             :mp nil)))))
           (values (ms->seconds time) events break)))))))

(add-act-r-command "run-n-events" 'run-n-events "Run the indicated number of events from the ACT-R scheduler. Params: event-count {real-time}." "Only one run allowed at a time")


(defun run-step ()
  (indicate-running
   (flet ((test (mp next-time count) 
                ;; the schedule-lock is held already while test is evaluated
                
                (declare (ignore next-time count))
                (loop
                  (when (null (meta-p-events mp))
                    (format t "No more events to process")
                    (return t))
                  (format t "Next Event: ~A~%" 
                    (let ((next (car (meta-p-events mp))))
                      (format-event next)))
                  (format t "[A]bort (or [q]uit)~%")
                  (format t "[D]elete~%")
                  (format t "[S]how event queue~%")
                  (format t "[W]aiting events~%")
                  (format t "[B]uffer contents~%")
                  (format t "[V]isicon~%")
                  (format t "[R]eport buffer status~%")
                  (format t "[E]xecute~%")
                  
                  (let ((response (read )))
                    (case response
                      ((a q) (return t))
                      (e (return nil))
                      (s (mp-show-queue))
                      (w (mp-show-waiting))
                      (b (show-buffer-chunks))
                      (v (print-visicon))
                      (r (buffer-status))
                      (d (pop (meta-p-events mp))))))))
     
     
     (let ((mp (current-mp)))
       (multiple-value-bind (time events break)
           (run-sched-queue mp #'test :real-time nil)
         (unless break
           
           (meta-p-output (format-event (make-act-r-event 
                                         :mstime (bt:with-recursive-lock-held ((meta-p-schedule-lock mp)) (meta-p-time mp))
                                         :module "------"
                                         :model '-
                                         :details "Stepping stopped"
                                         :output t
                                         :mp nil))))
         (values (ms->seconds time) events break))))))

(defun internal-dummy-event-fn (&rest r)
  (declare (ignore r)))


(defun schedule-event (time action 
                            &key (maintenance nil)
                            (module :none) (destination nil)
                            (priority 0) (params nil) 
                            (details nil) (output t)
                            (time-in-ms nil)
                            (precondition nil))
  (verify-current-model
   "schedule-event called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time) (>= time 0)))
            (print-warning "Time must be non-negative number."))
           ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and time-in-ms (not (integerp time)))
            (print-warning "When time-in-ms is true the time must be an integer."))
           ((and precondition (not maintenance))
            (print-warning "Only maintenance events may have a precondition."))
           ((or (and precondition (not (local-or-remote-function-p precondition)))
                (and (symbolp precondition) (macro-function precondition)))
            (print-warning "Precondition must be a function, but ~s provided." precondition))
           (t
            (let ((new-event (funcall (if maintenance
                                          #'make-act-r-maintenance-event
                                        #'make-act-r-event) 
                                      :mp nil
                                      :model (current-model-struct)
                                      :module module
                                      :mstime (if time-in-ms time (safe-seconds->ms time 'sechedule-event))
                                      :priority (if (numberp priority) priority 0)
                                      :min (and (eq priority :min) priority)
                                      :max (and (eq priority :max) priority)
                                      :action (if action action 'internal-dummy-event-fn)
                                      :params params
                                      :details details
                                      :output output
                                      :precondition precondition
                                      :destination destination)))
              
              (insert-queue-event mp new-event)
              
              (act-r-event-num new-event)))))))


(defun external-schedule-event (time action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-event '(:params :module :destination :priority :maintenance :output :time-in-ms :details :precondition))
    (when valid 
      (apply 'schedule-event time action (convert-options-list-items ol '(:module :destination :priority :output) nil)))))

(add-act-r-command "schedule-event" 'external-schedule-event 
                   "Create an event to occur at the specified time. Params: time action { < params, module, destination, priority, maintenance, output, time-in-ms, details, precondition > }."
                   nil)
  

(defun schedule-event-relative (time-delay action 
                                           &key (maintenance nil)
                                           (module :none) (destination nil)
                                           (priority 0) (params nil) 
                                           (details nil) (output t)
                                           (time-in-ms nil)
                                           (precondition nil))
  (verify-current-model
   "schedule-event-relative called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time-delay) (>= time-delay 0)))
            (print-warning "Time-delay must be non-negative number."))
           ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and time-in-ms (not (integerp time-delay)))
            (print-warning "When time-in-ms is true the time-delay must be an integer."))
           ((and precondition (not maintenance))
            (print-warning "Only maintenance events may have a precondition."))
           ((or (and precondition (not (local-or-remote-function-p precondition)))
                (and (symbolp precondition) (macro-function precondition)))
            (print-warning "Precondition must be a function, but ~s provided." precondition))
           (t
            (let ((new-event 
                   (funcall (if maintenance
                                #'make-act-r-maintenance-event
                              #'make-act-r-event)
                            :mp nil
                            :model (current-model-struct) 
                            :module module
                            :priority (if (numberp priority) priority 0)
                            :min (and (eq priority :min) priority)
                            :max (and (eq priority :max) priority)
                            :action (if action action 'internal-dummy-event-fn)
                            :params params
                            :details details
                            :output output
                            :precondition precondition
                            :destination destination)))
              
              (insert-queue-event mp new-event :delta (if time-in-ms time-delay (safe-seconds->ms time-delay 'schedule-event-relative)))
              
              (act-r-event-num new-event)))))))



(defun external-schedule-event-relative (delta-time action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-event-relative '(:params :module :destination :priority :maintenance :output :time-in-ms :details :precondition))
    (when valid 
      (apply 'schedule-event-relative delta-time action (convert-options-list-items ol '(:module :destination :priority :output) nil)))))

(add-act-r-command "schedule-event-relative" 'external-schedule-event-relative 
                   "Create an event to occur at the specified amount of time from now. Params: time-delay action { < params, module, destination, priority, maintenance, output, time-in-ms, details, precondition > }."
                   nil)


(defun schedule-event-now (action &key (maintenance nil)
                                  (module :none) (destination nil)
                                  (priority 0) (params nil) 
                                  (details nil) (output t)
                                  (precondition nil))
  (verify-current-model
   "schedule-event-now called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and precondition (not maintenance))
            (print-warning "Only maintenance events may have a precondition."))
           ((or (and precondition (not (local-or-remote-function-p precondition)))
                (and (symbolp precondition) (macro-function precondition)))
            (print-warning "Precondition must be a function, but ~s provided." precondition))
           (t
            (let ((new-event 
                   (funcall (if maintenance
                                #'make-act-r-maintenance-event
                              #'make-act-r-event)
                            :mp nil
                            :model (current-model-struct) 
                            :module module
                            :priority (if (numberp priority) priority 0)
                            :min (and (eq priority :min) priority)
                            :max (and (eq priority :max) priority)
                            :action (if action action 'internal-dummy-event-fn)
                            :params params
                            :details details
                            :output output
                            :precondition precondition
                            :destination destination)))
              
              (insert-queue-event mp new-event :now t)
              
              (act-r-event-num new-event)))))))

(defun external-schedule-event-now (action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-event-now '(:params :module :destination :priority :maintenance :output :details :precondition))
    (when valid 
      (apply 'schedule-event-now action (convert-options-list-items ol '(:module :destination :priority :output) nil)))))

(add-act-r-command "schedule-event-now" 'external-schedule-event-now 
                   "Create an event to occur at the current time. Params: time-delay action { < params,  module, destination, priority, maintenance, output, details, precondition > }."
                   nil)


(defun schedule-event-after-module (after-module action 
                                                 &key (maintenance nil)
                                                 (module :none) (destination nil)
                                                 (params nil) (details nil) 
                                                 (output t) (delay t)
                                                 (include-maintenance nil)
                                                 (dynamic nil)
                                                 (precondition nil))
  (verify-current-model
   "schedule-event-after-module called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (valid-module-name after-module))
            (print-warning "after-module must name a module."))
           ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and precondition (not maintenance))
            (print-warning "Only maintenance events may have a precondition."))
           ((or (and precondition (not (local-or-remote-function-p precondition)))
                (and (symbolp precondition) (macro-function precondition)))
            (print-warning "Precondition must be a function, but ~s provided." precondition))
           (t
            (let* ((new-event 
                    (funcall (if maintenance
                                 #'make-act-r-maintenance-event
                               #'make-act-r-event)
                             :mp nil
                             :model (current-model-struct) 
                             :module module
                             :min :min
                             :action (if action action 'internal-dummy-event-fn)
                             :params params
                             :details details
                             :output output
                             :precondition precondition
                             :destination destination
                             :dynamic dynamic
                             :wait-condition 
                             (list :module after-module 
                                   include-maintenance))))
              
              (insert-waiting-event mp new-event delay)
              (act-r-event-num new-event)))))))


(defun external-schedule-event-after-module (after-module action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-event-after-module '(:params :module :destination :maintenance :output :details :precondition :delay :include-maintenance :dynamic))
    (when valid 
      (apply 'schedule-event-after-module (string->name after-module) action (convert-options-list-items ol '(:module :destination :output :delay) nil)))))


(add-act-r-command "schedule-event-after-module" 'external-schedule-event-after-module 
                   "Create an event to occur after the next event for the named module. Params: after-module action {< params, module, destination, maintenance, output, details, precondition, delay, include-maintenance, dynamic > }"
                   nil)


(defun schedule-event-after-change (action 
                                    &key (maintenance nil)
                                    (module :none) (destination nil)
                                    (params nil) (details nil) 
                                    (output t) (delay t)
                                    (include-maintenance nil)
                                    (dynamic nil)
                                    (precondition nil))
  (verify-current-model
   "schedule-event-after-change called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and precondition (not maintenance))
            (print-warning "Only maintenance events may have a precondition."))
           ((or (and precondition (not (local-or-remote-function-p precondition)))
                (and (symbolp precondition) (macro-function precondition)))
            (print-warning "Precondition must be a function, but ~s provided." precondition))
           (t
            (let* ((new-event 
                    (funcall (if maintenance
                                 #'make-act-r-maintenance-event
                               #'make-act-r-event)
                             :mp nil
                             :model (current-model-struct) 
                             :module module
                             :min :min
                             :action (if action action 'internal-dummy-event-fn)
                             :params params
                             :details details
                             :output output
                             :precondition precondition
                             :destination destination
                             :dynamic dynamic
                             :wait-condition (list :any include-maintenance))))
              
              (insert-waiting-event mp new-event delay)
              (act-r-event-num new-event)))))))


(defun external-schedule-event-after-change (action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-event-after-change '(:params :module :destination :maintenance :output :details :precondition :delay :include-maintenance :dynamic))
    (when valid 
      (apply 'schedule-event-after-change action (convert-options-list-items ol '(:module :destination :output :delay) nil)))))


(add-act-r-command "schedule-event-after-change" 'external-schedule-event-after-change 
                   "Create an event to occur after the next event. Params: action {< params, module, destination, maintenance, output, details, precondition, delay, include-maintenance, dynamic > }"
                   nil)

(defun schedule-periodic-event (period action 
                                       &key (maintenance nil)
                                       (module :none) (destination nil)
                                       (priority 0) (params nil) 
                                       (details nil) (output t)
                                       (initial-delay 0)
                                       (time-in-ms nil))
  
  (verify-current-model
   "schedule-event called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp period) (> period 0)))
            (print-warning "period must be greater than 0."))
           ((not (and (numberp initial-delay) (>= initial-delay 0)))
            (print-warning "initial-dealy must be a non-negative number."))
           ((not (local-or-remote-function-or-nil action))
            (print-warning "Can't schedule ~S because it is not a valid command identifier." action))
           ((and (symbolp action) (macro-function action))
            (print-warning "Can't schedule ~S because it is a macro and not a function." action))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((not (listp params))
            (print-warning "params must be a list."))
           ((and time-in-ms (or (not (integerp period)) (not (integerp initial-delay))))
            (print-warning "When time-in-ms is true the period and initial-delay must be integers."))
           (t
            (let* ((real-event (funcall (if maintenance
                                            #'make-act-r-maintenance-event
                                          #'make-act-r-event) 
                                        :mp nil
                                        :model (current-model-struct) 
                                        :module module
                                        :max :max
                                        :action (if action action 'internal-dummy-event-fn)
                                        :params params
                                        :details details
                                        :output output
                                        :destination destination))
                   (id (bt:with-lock-held (*periodic-event-lock*)
                         (incf *periodic-event-id-counter*)))
                   (periodic-event 
                    (make-act-r-periodic-event 
                     :id id
                     :mp nil
                     :module :none
                     :model (current-model-struct) 
                     
                     :priority (if (numberp priority) priority 0)
                     :min (and (eq priority :min) priority)
                     :max (and (eq priority :max) priority)
                     :action 'periodic-action
                     :output nil
                     :details 
                     ;(format nil 
                     ;    "Periodic Action: ~A Period: ~A" action period)
                     (concatenate 'string
                       "Periodic-Action "
                       (if (and (symbolp action) (fboundp action)) (symbol-name action) (if (stringp action) action "Unnamed function"))
                       " "
                       (princ-to-string period)))))
              
              (insert-queue-event mp periodic-event :delta (if time-in-ms initial-delay (safe-seconds->ms initial-delay 'schedule-periodic-event)))
              
              (setf (act-r-event-params periodic-event) 
                (list periodic-event real-event (if time-in-ms period (safe-seconds->ms period 'schedule-periodic-event))))
              
              (setf (act-r-event-num real-event) (act-r-event-num periodic-event))
              
              (act-r-event-num periodic-event)))))))


(defun periodic-action (periodic-event real-event period)
  
  (let ((mp (current-mp)))
    (bt:with-recursive-lock-held ((meta-p-schedule-lock mp))
      (setf (act-r-event-mstime real-event) (act-r-event-mstime periodic-event))
      (insert-queue-event mp real-event)
      
      (setf (act-r-event-mstime periodic-event) (+ (act-r-event-mstime periodic-event) period))
      (insert-queue-event mp periodic-event))))
    


(defun external-schedule-periodic-event (period action &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-periodic-event '(:params :module :destination :maintenance :output :details :priority :time-in-ms :initial-delay))
    (when valid 
      (apply 'schedule-periodic-event period action (convert-options-list-items ol '(:module :destination :output :priority) nil)))))


(add-act-r-command "schedule-periodic-event" 'external-schedule-periodic-event 
                   "Create an event to occur repeatedly with the given period. Params: period action {< params, module, destination, maintenance, output, details, priority, time-in-ms, initial-delay > }"
                   nil)


(defun schedule-break (time &key (priority :max) (details nil)(time-in-ms nil))
  (let ((mp (current-mp)))
    (cond ((not (and (numberp time) (>= time 0)))
           (print-warning "Time must be non-negative number."))
          ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
           (print-warning "Priority must be a number or :min or :max."))
          ((and time-in-ms (not (integerp time)))
           (print-warning "When time-in-ms is true the time must be an integer."))
          (t
           (let ((new-event (make-act-r-break-event :mp nil
                                                    :mstime (if time-in-ms time (safe-seconds->ms time 'schedule-break))
                                                    :params (list mp)
                                                    :priority (if (numberp priority) priority 0)
                                                    :min (and (eq priority :min) priority)
                                                    :max (and (eq priority :max) priority)
                                                    :details details)))
             
             (insert-queue-event mp new-event)
             
             (act-r-event-num new-event))))))



(defun external-schedule-break (time &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-break '(:priority :time-in-ms :details))
    (when valid 
      (apply 'schedule-break time (convert-options-list-items ol '(:priority) nil)))))


(add-act-r-command "schedule-break" 'external-schedule-break
                   "Create a break event to force the current run to stop at the time indicated. Params: time {< details, priority, time-in-ms > }"
                   nil)



(defun schedule-break-relative (time-delay &key (priority :max) (details nil)(time-in-ms nil))
  (let ((mp (current-mp)))
    (cond ((not (and (numberp time-delay) (>= time-delay 0)))
           (print-warning "Time-delay must be non-negative number."))
          ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
           (print-warning "Priority must be a number or :min or :max."))
          ((and time-in-ms (not (integerp time-delay)))
           (print-warning "When time-in-ms is true the time-delay must be an integer."))
          (t
           (let ((new-event (make-act-r-break-event 
                             :mp nil
                             :params (list mp)
                             :priority (if (numberp priority) priority 0)
                             :min (and (eq priority :min) priority)
                             :max (and (eq priority :max) priority)
                             :details details)))
             
             (insert-queue-event mp new-event :delta (if time-in-ms time-delay (safe-seconds->ms time-delay 'schedule-break-relative)))
             
             (act-r-event-num new-event))))))




(defun external-schedule-break-relative (time-delay &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-break-relative '(:priority :time-in-ms :details))
    (when valid 
      (apply 'schedule-break-relative time-delay (convert-options-list-items ol '(:priority) nil)))))


(add-act-r-command "schedule-break-relative" 'external-schedule-break-relative
                   "Create a break event to force the current run to stop after the specified amount of time. Params: time-delay {< details, priority, time-in-ms > }"
                   nil)


(defun schedule-break-after-module (after-module &key (details nil) (delay t)(dynamic nil))
  (verify-current-model
   "schedule-break-after-module called with no current model."
   (let ((mp (current-mp)))
     (cond ((not (valid-module-name after-module))
            (print-warning "after-module must name a module."))
           (t
            (let* ((new-event (make-act-r-break-event 
                               :mp nil
                               :model (current-model-struct)
                               :min :min
                               :params (list mp)
                               :details details
                               :dynamic dynamic
                               :wait-condition 
                               (list :module after-module t))))
              (insert-waiting-event mp new-event delay)
              (act-r-event-num new-event)))))))


(defun external-schedule-break-after-module (after-module &optional params)
  (multiple-value-bind (valid ol) 
      (process-options-list params 'schedule-break-after-module '(:delay :dynamic :details))
    (when valid 
      (apply 'schedule-break-after-module after-module ol))))


(add-act-r-command "schedule-break-after-module" 'external-schedule-break-after-module
                   "Create a break event to force the current run to stop after the specified module's next action. Params: after-module {< details, delay, dynamic > }"
                   nil)

(defun schedule-break-after-all (&optional (details nil))
  (let* ((mp (current-mp))
         (new-event (make-act-r-break-event :mp nil
                                            :params (list mp)
                                            :min :min
                                            :details details)))
    
    (insert-final-queue-event mp new-event)
    
    (act-r-event-num new-event)))


(add-act-r-command "schedule-break-after-all" 'schedule-break-after-all
                   "Create a break event to force the current run to stop after the last event currently scheduled. Params: {details}"
                   nil)


(defun add-pre-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-pre-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (bt:with-lock-held ((meta-p-event-hook-lock mp))
       (cond ((not (local-or-remote-function-p hook-fn))
              (print-warning 
               "parameter ~s to add-pre-event-hook is not a function" hook-fn))
             ((member hook-fn (meta-p-pre-events mp))
              (when warn
                (print-warning 
                 "~s is already on the pre-event-hook list not added again"
                 hook-fn)))
             (t (push hook-fn (meta-p-pre-events mp))
                (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                  (cons :pre hook-fn))
                (1- (incf (meta-p-next-hook-id mp)))))))))
         

(add-act-r-command "add-pre-event-hook" 'add-pre-event-hook "Add a command to be called before each event is evaluated. Params: command {warn}")

(defun add-post-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-post-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (bt:with-lock-held ((meta-p-event-hook-lock mp))
       (cond ((not (local-or-remote-function-p hook-fn))
              (print-warning 
               "parameter ~s to add-post-event-hook is not a function" hook-fn))
             ((member hook-fn (meta-p-post-events mp))
              (when warn
                (print-warning 
                 "~s is already on the post-event-hook list not added again" 
                 hook-fn)))
             (t (push hook-fn (meta-p-post-events mp))
                (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                  (cons :post hook-fn))
                (1- (incf (meta-p-next-hook-id mp)))))))))

(add-act-r-command "add-post-event-hook" 'add-post-event-hook "Add a command to be called after each event is evaluated. Params: command {warn}")

(defun delete-event-hook (hook-fn-id)
  (verify-current-mp
   "delete-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (bt:with-lock-held ((meta-p-event-hook-lock mp))
       (let ((event (gethash hook-fn-id (meta-p-hook-table mp))))
         (when event
           (remhash hook-fn-id (meta-p-hook-table mp))
           (if (eq :pre (car event))
               (setf (meta-p-pre-events mp) 
                 (remove (cdr event) (meta-p-pre-events mp)))
             (setf (meta-p-post-events mp) 
               (remove (cdr event) (meta-p-post-events mp))))
           (cdr event)))))))

(add-act-r-command "delete-event-hook" 'delete-event-hook "Remove a previously added event hook command. Params: event-hook-id")


#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
