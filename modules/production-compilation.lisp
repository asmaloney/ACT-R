;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004-2007 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : production-compilation.lisp
;;; Version     : 5.0
;;; 
;;; Description : Implements the production compilation mechnaism in ACT-R 6.
;;; 
;;; Bugs        : 
;;;
;;; To do       : [X] Consider the handling of !safe-bind! in respect to doing
;;;             :     a direct substitution with the instantiated binding.
;;;             : [X] With the addition of the compilation-instan parameter
;;;             :     it may be possible to put the goal style slot remapping
;;;             :     back into the goal mapping function instead of directly
;;;             :     in the composition function, and then remove the clean-up
;;;             :     hack at the end.  Not entirely sure, but definitely worth
;;;             :     investigating at some point.
;;;             : [X v5.0] Consider whether dynamic slots which are used between
;;;             :     two productions (the pre-instantiate case) could remain
;;;             :     dynamic by only instantiating for the mapping.  Probably
;;;             :     leaves a lot of loose ends, but there are some notes in
;;;             :     the docs/notes/production-compilation-issues directory.
;;; ----- History -----
;;; 2005.04.26 Dan
;;;             : * Initial creation.
;;;
;;; 2005.05.18 Dan
;;;             : * Works to compose now, but doesn't yet have the parameter
;;;             :   learning pieces.
;;; 2005.05.19 Dan
;;;             : * Note that productions generated by compilation are 
;;;             :   created with p* because p*'s are a super set of p's
;;;             :   and that way p*'s can go through compilation without 
;;;             :   any special handling!
;;;             : * Fixed a bug in the composing functions because if a
;;;             :   buffer isn't mentioned in the first production it doesn't
;;;             :   actually have an index of 0.
;;;             : * Added the utility equation pieces, so it should be "fully"
;;;             :   operational (noting that it isn't defined if parameter
;;;             :   learning is set to use a decay value).
;;; 2005.05.20 Dan
;;;             : * Adding the threshold-time parameter.
;;; 2005.05.24 Dan
;;;             : * Some general clean up for speed and ease of reading for
;;;             :   the newly formed productions.
;;; 2005.05.25 Dan
;;;             : * Fixed an issue in compose-productions where ACL was letting
;;;             :   me get away with some sloppy code.
;;; 2005.05.26 Dan
;;;             : * Some more minor clean up for ease of reading the
;;;             :   the new productions - take out all = slot modifiers and
;;;             :   order the conditions as buffer tests, buffer queries, and
;;;             :   then !'s with the tests and queries in alphabetical order
;;;             :   by buffer name.
;;; 2005.05.27 Dan
;;;             : * Make sure that the compilation is disabled on a reset.
;;;             : * Added the initial-successes, initial-failures, and initial-
;;;             :   efforts parameters.
;;; 2005.06.01 Dan
;;;             : * Fixed a bug in compilation under MCL buffer-condition-
;;;             :   union was trying to set the second of something that was
;;;             :   nil which isn't a good idea, but didn't break in ACL though
;;;             :   I don't know why.
;;;             : * Ammended the tests for a valid production to include not 
;;;             :   having any direct requests and not using any slot modifiers
;;;             :   other than = for now.
;;; 2005.06.02 Dan
;;;             : * Some minor updates. 
;;;             : * Need to check that production name isn't already used 
;;;             :   explicitly since new-name only checks chunk names.
;;;             : * The test for slot modifiers needs to not look at evals and
;;;             :   binds because they may have similar structure...
;;; 2005.06.06 Dan
;;;             : * Fixed a bug in buffer-condition-union because it could be
;;;             :   the case that the first condition is blank and thus one
;;;             :   can't delete the isa from the second in that case.
;;; 2005.06.08 Dan
;;;             : * Changed define-chunk-spec-fct to define-variable-chunk-
;;;             :   spec-fct in produce-standard-representation because 
;;;             :   otherwise it blocks p*'s from being composed.  Since the
;;;             :   chunk-spec wasn't being use other than to order the
;;;             :   production components it shouldn't create any problems...
;;; 2005.06.16 Dan
;;;             ; * Fixed a bug in compose-productions with respect to
;;;             :   !safe-bind! because it wasn't properly copying all the
;;;             :   necessary pieces into the newly composed production.
;;;             : * Changed compose-productions so that it correctly orders
;;;             :   RHS safe-binds because the p2 bindings may depend on the
;;;             :   bindings of p1.  It also now checks to make sure that a
;;;             :   new production gets created without error to revent it 
;;;             :   from just crashing if that happens for some reason.
;;; 2005.08.15 Dan
;;;             : * Fixed a bug in that the hooks weren't removed if epl was
;;;             :   toggled from t to nil.  Thus, prior to this fix the only
;;;             :   way to disable was a reset once it was enabled.
;;; 2005.08.16 Dan
;;;             : * Fixed problems with the handling of !safe-bind! on the RHS.
;;;             :   The issues were if the substitution resulted in the var
;;;             :   being bound mapping onto a constant or if the var being
;;;             :   bound ends up on the LHS of the composed production after
;;;             :   mapping.  The solution (for now) is to convert those to
;;;             :   LHS !safe-eval! tests on the value in question instead.
;;;             : - Another potential solution is to treat !safe-bind! actions
;;;             :   like retrievals and just do the constant substitution with
;;;             :   the instantiated value.
;;;             : * Another situation with binds popped up - a RHS bind + a
;;;             :   LHS eval can result in an odd combination with an unbound
;;;             :   variable, so to fix that there's currently a fix to move
;;;             :   the bind to the LHS.  That then makes the new production
;;;             :   a dead end for compilation, but doesn't cause the system
;;;             :   to crash.
;;; 2005.08.17 Dan
;;;             : * Major change in how !safe-bind! is handled!
;;;             :   Now, instead of trying to catch all the gotchas, a RHS
;;;             :   binding in the first production will be treated like a
;;;             :   retrieval for substitution - the explicit value bound
;;;             :   in the instantiation will be propigated forward into the
;;;             :   new production and the form that was evaluated will be
;;;             :   discarded.
;;;             :   That means that there should be no side effects in the
;;;             :   evaluation of a !safe-bind! because they will not be
;;;             :   carried over to a compiled production!
;;; 2005.08.19 Dan
;;;             : * Continuing to update how binds work.  Not only will the
;;;             :   value of the bound variable be captured, but all variables
;;;             :   that are referenced in the bind expression will be replaced
;;;             :   with their instantiated values from the first production.
;;; 2005.08.22 Dan
;;;             : * More work on the mechanism.  Now, adding a (somewhat)
;;;             :   redundant check to make sure productions are compatible.
;;;             :   This check ensures that a buffer doesn't violate the
;;;             :   assumptions that underlie the style - for instance that
;;;             :   the goal chunk doesn't change other than through a
;;;             :   production.
;;;             :   Right now it's only a check of goal style buffers because
;;;             :   we want partial matching (which may be inconsistent) for
;;;             :   retrieval style buffers and motor and perceptual buffers
;;;             :   don't compile across modifications or requests to begin
;;;             :   with.  This needs to be made more general though so that
;;;             :   it also can be user extended.
;;; 2005.09.01 Dan
;;;             : * Added a call to with-unchecked-p* around the generation of
;;;             :   the new production to allow non-variable new slot creation
;;;             :   (which could happen after substitution in a generated
;;;             :   production).
;;; 2005.09.02 Dan
;;;             : * Patch work to fix issues with p* in general that were
;;;             :   uncovered while testing the slot creation code.
;;;             :   Main issue is that modifications in the first production
;;;             :   need to have the slot names instantiated so that all the
;;;             :   conditions of the second that were set by the first can
;;;             :   be detected.
;;;             : * Since only goal style modules allow buffer modification,
;;;             :   that's where I've applied the fix, but if other styles are
;;;             :   to allow mods then that will have to be handled there too.
;;; 2005.11.09 Dan
;;;             : * Fix for a problem in composing a p1 that makes a retrieval
;;;             :   request with a p2 that doesn't mention retrieval at all.
;;;             :   The request was being dropped, but shouldn't have been.
;;; 2005.12.12 Dan
;;;             : * Temporary fix to composing p* variablized slots (instead of
;;;             :   just instantiating them).  This is a hack John put in and
;;;             :   I'm working on making it more general.
;;; 2005.12.14 Dan
;;;             : * Moved the fix into the goal-style buffers explicitly since
;;;             :   they're the only ones where it's an issue because none of
;;;             :   the other styles allow for a RHS modification.
;;; 2005.12.15 Dan
;;;             : * Realized that I can't do it in the goal buffer processing
;;;             :   because the "normal" variable mapping process needs the
;;;             :   change before it progresses (which occurs before it goes
;;;             :   to the buffer specific code).  So, it's in the main 
;;;             :   function and conditionalized to only occur for the special
;;;             :   case necessary (goal style buffer with a RHS modification).
;;; 2005.12.20 Dan
;;;             : * Minor changes to clean up some compiler warnings.
;;; 2006.01.17 Dan
;;;             : * Time to change the version number and module info text.
;;;             :   It's now version 1.0.
;;; 2006.02.03 Dan
;;;             : * Another issue with p*'s that I don't really have a good
;;;             :   handle on at this point (see pstar-test8.lisp in the test-
;;;             :   models folder for an example).  So, for now I've taken the
;;;             :   easiest approach and just clean-up after the fact.  Which
;;;             :   might be a good idea in general, but doesn't feel quite
;;;             :   right...
;;; 2006.02.07 Dan
;;;             : * Make sure that the RHS !safe-bind! calls in p2 come before the
;;;             :   !safe-eval! and !output! calls in p3 to avoid issues with
;;;             :   unbound vars.  Maintaining original order might be a nice
;;;             :   thing to have, but the "standard rep" loses that at this 
;;;             :   point to allow for better comparisons.  So, if that's really
;;;             :   necessary it'll require some more extensive changes.
;;; 2006.03.10 Dan
;;;             : * Fixed calls to get-production because it no longer requires
;;;             :   the procedural module as a parameter.
;;;             : * Removed the learned-productions slot of the module and
;;;             :   instead made it a parameter on the productions themselves.
;;;             : * Updated update-params-for-compiled-production to not do
;;;             :   the utility computation, but instead to call the functions
;;;             :   in the utility-and-reward file.
;;; 2006.03.13 Dan
;;;             : * Removed all the utility parameters from the compilation
;;;             :   module because they're now part of the utility module.
;;; 2006.03.14 Dan
;;;             : * Fixed a bug that was introduced with the !safe-bind! fix
;;;             :   that caused RHS buffer references to be instantiated.
;;; 2006.03.14 Dan
;;;             : * Switched call to pp to (all-productions).
;;; 2006.07.12 Dan
;;;             : * Fixed the typo in the documentation of the :pct parameter.
;;; 2006.08.29 Dan
;;;             : * Fixed a bug in compose-productions where it was creating
;;;             :   the comment string for the new production.  It was iterating
;;;             :   over all buffers to determine if any were "removed" which
;;;             :   would throw a warning for a buffer that wasn't used now.
;;;             :   Instead, it only needs to check the buffers actually used
;;;             :   on the LHS of p2 which avoids the bug and is generally 
;;;             :   going to save a little time during compilation.
;;; 2006.09.07 Dan
;;;             : * Changed reset-production-compilation so that imaginal is
;;;             :   a goal type by default.
;;; 2006.11.10 Dan
;;;             : * Use the new dynamic slot of productions so that compilation
;;;             :   only creates p*s when a parent production is a p*.
;;; 2006.11.16 Dan
;;;             : * Changed update-params-for-compiled-production so that when
;;;             :   it deletes the new productions it also releases the name
;;;             :   symbol using release-name.
;;; 2006.11.17 Dan
;;;             : * Added a compilation-buffer-type macro and renamed the
;;;             :   function with -fct.
;;;             : * Added a call to values around the gethash in compilation-
;;;             :   buffer-type to suppress the second return value.
;;;             : * Changed specify-compilation-buffer-type to return t/nil only.
;;;             : * Fixed a bug in specify-compilation-buffer-type because it
;;;             :   was missing parameters in the calls to print-warning.
;;; 2007.01.15 Dan
;;;             : * Fixed a bug that was introduced with the change on 11/16
;;;             :   that would break when releasing the name.
;;; 2007.02.01 Dan
;;;             : * Fixed a bug in the instantiating necessary when a goal
;;;             :   style buffer in a p* modifies a chunk with a variablized
;;;             :   slot, or after any modification the p2 has a variablized
;;;             :   condition test.  Previously it only instantiated if both
;;;             :   cases where satisfied instead of either which could lead
;;;             :   to "incorrect" productions.  Probably a pretty rare situation,
;;;             :   since p*'s and production compilation are both sparsely 
;;;             :   used so I'm guessing that this hasn't been an issue for 
;;;             :   anyone else. (John didn't even encounter it!)
;;; 2007.04.10 Dan
;;;             : * Changed the comment string added to the new production so
;;;             :   that it only indicates the '- chunk' when the first production
;;;             :   actually made a request to the retrieval type buffer which
;;;             :   was matched in the second.  Previously, as long as the
;;;             :   second production tested such a buffer it would add that
;;;             :   to the comment.
;;;             : * Fixed a bad bug in compose-retrieval-buffer.  If p1 had
;;;             :   a retrieval request and p2 had a query of that buffer without
;;;             :   a harvest (thus it must be state busy or buffer empty) then
;;;             :   the composed production actually dropped the request from
;;;             :   the actions as if it was harvested!
;;;             : * Added a fix for an issue with retrieval drop-out when
;;;             :   the request had dynamic slot names.  There are still
;;;             :   a couple of issues to work out, but this should catch
;;;             :   many of the current problem cases.
;;; 2007.04.11 Dan
;;;             : * Added a better check for whether a compiled production is
;;;             :   dynamic and should be created with p* instead of just assuming
;;;             :   that it was based on the parents.
;;;             : * Added a new parameter to productions: compilation-instan.
;;;             :   It's used to hold the instantiation of p2 during compilation 
;;;             :   which is the bindings from the matching of p2 where some of the
;;;             :   variables may have been renamed to avoid conflicts with the 
;;;             :   variables from p1.
;;;             : * Using that new parameter, fixed a bug in the drop-out of
;;;             :   a retrieval which involved dynamic slots that had been renamed
;;;             :   in p2.
;;; 2007.05.21 Dan
;;;             : * Fix a bug that surprised me because nobody had found it yet -
;;;             :   when compiling out a retrieval if p2 used the "dropped" buffer
;;;             :   variable on the RHS it wasn't instantiated.  Not as easy a 
;;;             :   fix as first thought either because p1 could use that variable
;;;             :   name on it's LHS or RHS and those shouldn't be replaced...
;;;             : * Required adding the new production parameter retrieval-buffers-map
;;;             :   to keep things straight (sort of a hack, but I think it works
;;;             :   out ok).
;;; 2007.05.22 Dan
;;;             : * Similar to the bug listed above, compilation over goal style buffers
;;;             :   is allowed to progress (or fails with a warning in some cases)
;;;             :   when there is a use of the buffer variable in the actions of
;;;             :   p2 but a request in p1 invalidates that for the compiled production.
;;;             :   Updated the spreadsheet/data table to add a check for that.
;;; 2007.07.03 Dan
;;;             : * Fixed check-consistency because it was overly specific in
;;;             :   testing that things matched.  Replaced the eq test of the
;;;             :   slot contents with chunk-slot-equal.
;;; 2007.10.26 Dan [1.3]
;;;             : * Sorting the actions in the composed productions so that
;;;             :   the "same" production gets created in all systems.  Otherwise
;;;             :   they can vary in the action order which shouldn't matter, but
;;;             :   for some rare situations might.
;;; 2008.03.20 Dan
;;;             : * Putting in a test so that productions with multiple-value binds 
;;;             :   are always rejected from compilation.
;;; 2008.12.23 Dan
;;;             : * Put in code to make sure that new productions get added to
;;;             :   the procedural module the "right" way now.
;;; 2009.08.27 Dan
;;;             : * Added code to disable the consistency check between the
;;;             :   RHS modifications of p1 and the LHS tests of p2 for goal
;;;             :   style buffers when ppm is enabled.
;;; 2009.09.14 Dan
;;;             : * Fixed a bug in the consistency check added for the ppm change.
;;; 2010.11.22 Dan [1.4]
;;;             : * Start of the changes to update this to allow for buffer
;;;             :   modification requests, create a new type for imaginal,
;;;             :   and make things more easily extendable.
;;;             : * First pass is just the ability for get-buffer-index to
;;;             :   distinguish a normal request from a modification request
;;;             :   with modification requests just adding another bit to the
;;;             :   numbers.
;;;             : * Updated the docs to describe things a little better with
;;;             :   respect to the spreadsheets which are involved and are
;;;             :   how they are going to be used in the new implementation.
;;; 2010.11.23 Dan
;;;             : * Updated valid-1st-p to allow for both a modification and
;;;             :   standard request in a single production.
;;; 2010.11.24 Dan
;;;             : * Replaced the separate tables with a single table that
;;;             :   holds structures with a type's info.
;;; 2010.11.29 Dan
;;;             : * Don't like mixing changes, but in addition to updates for
;;;             :   the new more flexible compilation type handling I've added
;;;             :   some pre-caching of things that can take a while to compute
;;;             :   and are likely to be computed often: valid-1st-p, valid-for-
;;;             :   compilation, and a table for testing whether two productions
;;;             :   are composeable.
;;; 2010.12.06 Dan
;;;             : * Finished off the generalizing and moved all the buffer type
;;;             :   specific code to the corresponding files in the tools 
;;;             :   directory.  
;;;             : * Still need to clean up the details for the specifics of
;;;             :   handling the modification requests in those specific files.
;;; 2010.12.07 Dan
;;;             : * Changed update-params-... so that when :pct is on the
;;;             :   production is printed through print-production directly
;;;             :   instead of pp so that I can send it to the model trace 
;;;             :   instead of the command trace.
;;; 2010.12.15 Dan
;;;             : * Added the module as the first parameter passed to the 
;;;             :   mapping function.
;;; 2010.12.17 Dan
;;;             : * Added a new test to valid-compilation-production to check
;;;             :   for redundant variable usage.  It won't stop compilation,
;;;             :   but will print a warning if such useage is found.
;;; 2010.12.20 Dan
;;;             : * Allow the consistency check to pass for chunks of a subtype
;;;             :   in either direction between the two if specified in the
;;;             :   test.
;;; 2011.04.26 Dan
;;;             : * Use the millisecond times internally.
;;; 2011.04.28 Dan
;;;             : * Added some declaims and declares to avoid compiler warnings.
;;;             : * Suppress warnings about extending productions at initial load.
;;; 2011.08.23 Dan
;;;             : * Changed how get-buffer-index handles a direct request so that
;;;             :   they may to a + instead of a * for the validity table.  Doesn't
;;;             :   affect anything for compilation since productions with 
;;;             :   direct requests get pruned as invalid for compilation, but
;;;             :   other code which may use that index might care.
;;; 2011.09.13 Dan
;;;             : * Removed an errant debugging print out.
;;; 2012.04.04 Dan [1.5]
;;;             : * Added more detail to the compilation trace.  It now includes
;;;             :   a description of why a production was not valid for compilation
;;;             :   and will display the details reported by a buffer type if it
;;;             :   reports any.  A compilation type now has to specify whether
;;;             :   it has a whynot reason function which is the 9th parameter
;;;             :   passed to define-compilation-type.  If a whynot-reason function 
;;;             :   is specified it will be called with 3 parameters -- the p1 index
;;;             :   the p2 index and either the name of a test function which failed
;;;             :   or nil if no test function was called.
;;; 2012.11.20 Dan
;;;             : * Fixed a bug with how the comment string for the compiled production
;;;             :   was set when there's a dropout buffer which only occurs in the
;;;             :   conditions of the second production.
;;; 2014.05.07 Dan [2.0]
;;;             : * Start the conversion to the typeless chunk operation and
;;;             :   the modified production syntax.
;;; 2014.05.19 Dan
;;;             : * Removed the allow-subtypes keyword from check-consistency.
;;; 2015.06.04 Dan
;;;             : * Use safe-seconds->ms for recording the :tt value.
;;; 2015.07.28 Dan
;;;             : * Changed the logical in build-compilation-type-file to ACT-R.
;;; 2016.06.10 Dan
;;;             : * Fixed a bug with these two productions being considered
;;;             :   equivalent:
;;;             :    (p STEP3 =GOAL> ISA GOAL STEP 3 ==> =GOAL> STEP 1)
;;;             :    (p PRODUCTION0 =GOAL> isa goal STEP 1 ==> =GOAL> STEP 3)
;;;             :   Which happens because the isa goal isn't a part of the 
;;;             :   standard representation now so it ends up matching the lhs
;;;             :   of one to the rhs of the other and vice-versa.  
;;;             :   Equivalent-productions-p now tests lhs and rhs separately to
;;;             :   avoid that.
;;; 2016.07.01 Dan
;;;             : * Removed some old code that's not used anymore.
;;;             : * Replaced remove-buffers with basic-variables which accesses
;;;             :   a value that's stored in a table of the compilation module
;;;             :   since there's a sizeable cost to recomputing that everytime
;;;             :   and making it a production parameter requires two hash-table
;;;             :   lookups instead of one.
;;;             : * Replaced the format in convert-cmd to a concatenate.
;;; 2016.09.28 Dan
;;;             : * Removed code that checks for multiple meta-processes from
;;;             :   define-compilation-type.
;;; 2017.08.11 Dan
;;;             : * Protect access to production structures right at the top
;;;             :   in compile-productions to avoid having to catch it everywhere
;;;             :   below that.
;;; 2018.04.17 Dan [3.0]
;;;             : * Add locks to protect the tables and the modules.
;;;             : * Add remote versions of the user commands.
;;; 2018.06.22 Dan
;;;             : * Only external commands need to convert names.
;;; 2020.04.24 Dan
;;;             : * Set style-check off when creating the composed production
;;;             :   to avoid checking (don't rely on delay-tree to do that now).
;;; 2020.05.01 Dan
;;;             : * Removed a check of use-tree as well since it's not needed. 
;;;             :   Sets the delay extra flag initially and then call add-
;;;             :   production-extra-setup when done so that all the details for
;;;             :   other code can stay in the procedural module.
;;; 2020.06.11 Dan
;;;             : * Fix a potential problem with equivalent-productions-p not 
;;;             :   considering two productions equivalent because their buffer-
;;;             :   indices values aren't in the same order.  Not a likely 
;;;             :   occurrence since if they're compiled productions then they'd
;;;             :   almost certainly have to have resulted in the same order,
;;;             :   but a starting production could have been written with the
;;;             :   buffer tests and actions ordered in such a way that the 
;;;             :   indices end up ordered differently.
;;; 2020.06.12 Dan
;;;             : * Keep a table of production "signatures" for testing with
;;;             :   equivalent-productions-p so don't always have to test all of
;;;             :   them.  Use the new :add-produciton-hook to store them in
;;;             :   the table.
;;; 2020.06.17 Dan [4.0]
;;;             : * Allow LHS safe-binds now, but disallow using safe-bind
;;;             :   vars in other safe-bind expressions to make it tractable to
;;;             :   determine equivalence (there are problems with the test that
;;;             :   existed prior to this for this and other reasons).
;;;             : * Changed the internal standard-representation so that it
;;;             :   isn't necessary to translate into and out of the buffer
;;;             :   variable symbol.
;;;             : * The pre-instantiate setting for a compilation type now needs
;;;             :   to be either t or nil.  It can't be a function to compute
;;;             :   whether to do so or not for consistency reasons.
;;; 2020.06.24 Dan
;;;             : * Added another lookup table for testing equivalence.  Store
;;;             :   composed productions in a table based on their documentation
;;;             :   and check those items first for equivalence since unless 
;;;             :   there are RHS !safe-binds! or ppm is enabled it should be a
;;;             :   match to what's there without having to check the more 
;;;             :   general table.
;;; 2020.06.25 Dan
;;;             : * Fixed an issue with !safe-bind! from p2 getting duplicated
;;;             :   in p3.
;;;             : * Marked the to do actions as done (not entirely sure I know
;;;             :   what the first referred to but seems like it's done now) and
;;;             :   the second was addressed a while ago.
;;; 2020.07.06 Dan
;;;             : * Added a declare ignorable to equivalent-productions-p to
;;;             :   avoid a compilation warning in single-threaded mode.
;;; 2020.07.22 Dan
;;;             : * Fixed an issue with a retrival drop-out trying to instantiate
;;;             :   the variable in a LHS !safe-bind! (the RHS ones are already
;;;             :   instantiated and dropped).
;;;             : * Turns out RHS p2 aren't dropped, but they should be ok now.
;;; 2020.11.04 Dan [4.1]
;;;             : * Fixed an issue with buffer name variables being renamed
;;;             :   when they occur in both productions.  This fix simply treats
;;;             :   buffer name variables which occur in the LHS of the 
;;;             :   production as not "basic variables" that will be renamed.
;;;             :   This seems to do the right thing for most of the error cases
;;;             :   that were found, but it does introduce some productions that
;;;             :   aren't right in subtle ways where previously it would have
;;;             :   failed to create a production because of the unbound vars.
;;;             :   The most significant of those relate to the buffer changing
;;;             :   due to a request between them which causes the buffer var
;;;             :   to have different values in the productions.  The current
;;;             :   plan for a fix to that is to just disallow their composition
;;;             :   which shouldn't break anything since before they would have
;;;             :   either created a "bad" production or failed to produce one
;;;             :   at all.  That's going to be a separate update once all of
;;;             :   the details are worked out.  That will still leave some very
;;;             :   obscure issues, mostly related to the fact that the 
;;;             :   imaignal-action buffer is a hidden !eval! which can do all
;;;             :   kinds of things to mess it up, but those are also issues now
;;;             :   anyway.
;;; 2020.11.05 Dan [4.2]
;;;             : * Prevent composition of two productions if p2 uses a buffer
;;;             :   variable on the LHS and there's a request for that buffer in 
;;;             :   the first production.
;;; 2020.11.09 Dan [4.3]
;;;             : * Fixed an issue with composing dynamic productions which was
;;;             :   broken with the 4.0 update.  Considered allowing a more
;;;             :   general solution that only instantiates for the mapping, but
;;;             :   not going to do so at this point.
;;; 2020.11.10 Dan [4.4]
;;;             : * Speculative attempt to allow productions with RHS indirect 
;;;             :   actions to be compiled.  It replaces the variable or chunk
;;;             :   with all the slots and values as is done for the action at
;;;             :   run time.  So, effectively it compiles the chunk into the
;;;             :   production much like dropping out the retrieval -- the 
;;;             :   composed production doesn't have any indirection.
;;;             : * Added a parameter, :cia (compile indirect actions) to enable
;;;             :   or disable that (disabled by default).
;;;             : * Split standard-rep into it's two parts (standard-rep and
;;;             :   composition-rep) and make those production parameters so the
;;;             :   locking protection is automatic (it wasn't being protected 
;;;             :   previously).  Also add standard-rep-sides to hold the lhs
;;;             :   and rhs pieces that are shared between the two.
;;; 2020.11.18 Dan [4.5]
;;;             : * Instantiate the LHS variable binding along with the RHS
;;;             :   actions, which requires checking whether any variables are
;;;             :   used in an indirect action are bound in a !safe-bind!.
;;;             : * Requires a test that indirect requests are valid chunks to
;;;             :   avoid creating an invalid production which means that
;;;             :   produce-composition-representation has to detect the issue
;;;             :   which happens now if it returns a string and that's tested
;;;             :   in compose-production.
;;;             : * Also added some code to investigate allowing retrieval style 
;;;             :   buffer actions from p2 to remain indirect, but that's not
;;;             :   a usable mechanism at this point.
;;; 2020.11.20 Dan 
;;;             : * Starting to use the :rir parameter to keep retreival style 
;;;             :   buffers' indirect actions indirect when possible (not usable
;;;             :   yet).
;;; 2020.11.24 Dan
;;;             : * I think this works for retaining the indirect requests where
;;;             :   possible when :rir is set and rejecting cases that can't be
;;;             :   composed (instantiating bind variables), but needs more 
;;;             :   testing to be certain.
;;; 2020.12.01 Dan [4.6]
;;;             : * More testing suggests :rir is stable, and with some minor
;;;             :   cleanup of the code it's being made available now.
;;; 2021.01.11 Dan
;;;             : * Fixed an issue with variabilized slots in actions which are
;;;             :   set with explicitly bound variables not properly creating
;;;             :   the new production.
;;; 2021.02.08 Dan
;;;             : * Fix a bug where removal of duplicate LHS safe-binds didn't
;;;             :   remap the variables in RHS safe-eval and output commands
;;;             :   that were added from p2.
;;; 2021.02.10 Dan [5.0]
;;;             : * Remove the pre-instantiation step and put that on the buffer
;;;             :   mechanisms to handle in the mapping and composing fns when
;;;             :   needed because it was preventing some desired generality and
;;;             :   didn't actually work "right" in some cases.
;;; 2021.02.19 Dan
;;;             : * When composing the buffer= and buffer+ actions need to 
;;;             :   exclude dynamic p1 slots whose instantiation is overridden
;;;             :   with something in p2 (which may also have been dynamic).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;; Specific details of the production compilation process can be found in the
;;; compilation.doc file in the docs/notes directory, but some general information 
;;; about the mechanism is included here as well.
;;;
;;; The basic mechanism is that for any two productions that fire in sequence
;;; a new production may be created that is a composition of those two (typically
;;; referred to as "compiling" those productions).
;;;
;;; To determine whether two productions can be composed and how they get 
;;; composed depends on what buffers are used and how they are used.
;;;
;;; Here's the high-level algorithm in a text-based state chart (best
;;; viewed in a fixed width font):
#|
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                                             start
                                                               |
                                                               V
                                                               |
                                                    -------------------------
        .--------------------.--------------------->| Wait for a production |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    |                                 |
        |                    |                      ------------------------- 
        |                    |                      | call it current       |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    ^                                 |
        |                    |                       /---------------------\
        |            ------------------             /  is current valid-p   \
        |            | clear previous | ------<--N- \                       / 
        |            ------------------              \---------------------/
        |                    |                                 | 
        |                    |                                 Y
        |                    |                                 |
        |                    ^                                 V
        |                    |                                 |
        ^                    N                                 |
        |                    |                      /---------------------\
----------------      /-----------\                /  is there a previous  \
| set previous |     / is current  \---------<--N- \                       /
| to current   |-<-Y-\ valid-1st-p /                \---------------------/
----------------      \-----------/                            |
                             |                                 | 
                             |                                 Y
                             |                                 |
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                       /---------------------\
                             |                      /   are previous and    \
                             +----------------<--N- \ current composable    /
                             |                       \---------------------/
                             |                                 | 
                             |                                 Y
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                      --------------------------
                             +----------------<---- | Compose new production |
                                                    --------------------------
|#

;;; The test for valid-p is that it have none of the following:
;;;    - LHS !eval!
;;;    - LHS !bind!
;;;    - LHS !mv-bind!
;;;    - RHS !eval!
;;;    - RHS !bind!
;;;    - RHS !mv-bind!
;;;    - multiple LHS ='s for any one buffer.
;;;    - No indirect actions if :cia is set to nil
;;;    - No indirect actions for any buffer using a !safe-bind! variable if :cia is t and :rir is nil
;;;    - No indirect actions for all non-retrieval style buffers using a !safe-bind! variable if :cia is t and :rir is t  
;;;    - No overwrite actions
;;;    - No slot modifiers other than = in the conditions.
;;;    - No "nesting" of !safe-bind! variables i.e. using a
;;;      variable bound with safe-bind in the expression of
;;;      a different safe-bind on the same side of the production.
;;;   
;;;
;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - more than one action of a particular type for a specific buffer of any style
;;;      though it may have a single modification, a single request, and a single modification request
;;;      for each buffer
;;;
;;; The test of composable is a lot more involved. 
;;; 
;;; First, the productions must fire within the threshold time of each other.
;;; Then, for each buffer used in either production the composition charts
;;; are consulted to determine if its useage is composeable.  If all of the buffers are
;;; composeable given their usage, there is a check to ensure that the buffer actions 
;;; in the first are compatible with the conditions in the second to avoid any problems
;;; with an "unusual" change in the buffer.  The last check is to see there are any 
;;; buffers with a request in the first production and the use of that buffer's variable
;;; in the conditions of the second, and if so they can't be composed.
;;;
;;; The default composition process considers buffers to fall into one of 5 general
;;; types (goal, imaginal, retrieval, perceptual, and motor) and the mechanism differs
;;; based on the types of buffers used in the two productions.  The Microsoft 
;;; Excel file "compilation.xls" in the docs directory lays out the tables that
;;; govern the composabilty of productions based on the types of buffers
;;; used and the conditions and actions they contain.  
;;;
;;; Here's a guide for how to read those sheets.  The A1 cell holds the 
;;; name of the compilation buffer type being specified.  B1 holds
;;; the function to call for mapping of constants to variables between
;;; the two productions' buffer usage or nil if no such mapping is necessary.
;;; C1 holds the function to call for creating the conditions and actions for 
;;; that buffer in the new production.  Cell D1 holds the name of a function to call for
;;; performing any extra compatibility test necessary after composability
;;; has been determined for the productions, or the value nil if there is
;;; no additional test necessary for this type.  Cell E1 is no longer used.
;;; Cell F1 is t or nil to indicate whether a request-harvest pair of the buffer
;;; should be dropped out.  Cell G1 holds the name of a function to call to provide
;;; some details when this type blocked the composition of two productions.  Cell A2
;;; is a list of the buffers which will be set to this type, or the value :default if 
;;; this should be the default type for any unspecified buffers. 
;;;
;;; The table in rows 5-45 specifies the conditions under which the
;;; usage of this buffer type in the two productions can be composed.
;;; The rows are for buffer usage in the first production and the
;;; columns are for the buffer's usage in p2.  The number is a
;;; reference used internally for representing the condition which
;;; is displayed symbolically in the table.  There are 6 ways which the
;;; buffer may be used in a production:
;;; 
;;; LHS test: =
;;; LHS query: ?
;;; RHS modification: =
;;; RHS explicit clear: -
;;; RHS request: +
;;; RHS modification request: *
;;;
;;; In the symbolic representation the > is used to separate lhs and rhs
;;; usage, a "." separates items on the same side and empty brackets {}
;;; indicates no usage of the buffer on that side.  Order doesn't
;;; matter since the production testing is considered in parallel and
;;; actions have a fixed priority regardless of the order in the production.
;;; Thus, =>=.+.* is a production with a lhs test of the buffer and then
;;; a modification, a request, and a modification request on the RHS.
;;;
;;; The cells of the table indicate whether or not productions with those
;;; particular usages can be composed.  If it is nil then they can not be.
;;; If it is t then they can without restrictions, and if it is any other
;;; value that names a function to call to test some additional constraint
;;; which must be met to compose those productions.  The description of
;;; those functions' operations are described below the table along with
;;; some additional comments about this type of buffer.
;;;
;;; The text files saved from those spreadsheets are used directly to 
;;; generate the buffer composition files found in the tools directory.
;;; The idea is that if one wants to either modify or extend the compilation
;;; mechanism, then that can be done by changing or adding new spreadsheets
;;; and then rebuilding or adding the corresponding composition file instead of
;;; having to recode the whole thing.  That may require also adding some new
;;; testing functions or composition functions, but it should not require
;;; changing the code or mechanisms in this file.
;;;   
;;; The default assignment of buffers to types based on the current
;;; spreadsheets is as follows (assuming that a buffer by that name exists):
;;;
;;; Buffer name           Type
;;;  goal              goal
;;;  imaginal          imaginal
;;;  retrieval         retrieval
;;;  visual-location   perceptual
;;;  visual            perceptual
;;;  aural-location    perceptual
;;;  aural             perceptual
;;;  manual            motor
;;;  vocal             motor
;;; 
;;; The default type is motor, thus any other buffer will be assumed to be of 
;;; type motor unless configured using the specify-compilation-buffer-type 
;;; command (which can also be used to change the types for the default buffer 
;;; assignments).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;; 
;;; defmacro specify-compilation-buffer-type (buffer-name buffer-type)
;;; defun   specify-compilation-buffer-type-fct (buffer-name buffer-type)
;;;
;;; buffer-name must be the name of a valid buffer in the model.
;;; buffer-type must be one of the symbols goal, imaginal, retrieval, perceptual, 
;;; motor, or the symbol naming another type which is created using 
;;; define-compilation-type.
;;;
;;; If the named buffer exists and the symbol for the buffer-type is valid this
;;; command will cause production compilation to treat the named buffer as a
;;; member of the specified type for composition purposes.
;;; 
;;; If the parameters are valid and there is a current production compilation
;;; module, then the command will return t otherwise it will print a warning 
;;; and return :error.
;;;
;;; If this command is to be used by a module to set its default type it
;;; should be done in the second module reset function.  If it is being set in
;;; the model, then it should occur within the body of the model.  Changing 
;;; the values at times other than reset or model creation are not advised and
;;; may lead to unpredictable behavior.
;;;
;;; defun show-compilation-buffer-types ()
;;;
;;; This command will print out a table showing the current compilation buffer
;;; type for each of the buffers in the system.  If there is no current module
;;; then it will print a warning.
;;; 
;;; It always returns nil.
;;;
;;; Parameters:
;;;   :cia - T or nil (default nil) set to t to allow compilation to occur for
;;;          productions which have indirect actions (those specified only by
;;;          a name)
;;;   :epl - T or nil (default nil) set to t to enable production learning 
;;;   :pct - T or nil (default nil) set to t to display details of the 
;;;          production compilation process in the trace
;;;   :rir - T or nil (default nil) set to t to have indirect retrieval style
;;;          buffer actions which stay in the production remain indirect 
;;;   :tt  - a positive number (default 2.0) threshold time in seconds which
;;;          productions must fire within to be valid for compiling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;;
;;; Originally kept separate from the main procedural module as a precautionary
;;; measure while it was being developed, but now that separation seems like
;;; the right thing to do anyway to keep things clean.
;;;
;;; The dependence on and usage of the low-level production structure is not
;;; an ideal thing especially considering the option of extendability, but for
;;; now that's going to remain because it is convenient.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)

(declaim (ftype (function (t t t) t) update-utility-for-compiled-production))
(declaim (ftype (function (t) t) spp-fct))
(declaim (ftype (function (t t t) t) initialize-utility-for-compiled-production))

;;; Add a new parameter to productions to track who created it

(suppress-extension-warnings)

(extend-productions user-created :default-value t)


;;; Add a new parameter to productions for holding the bindings
;;; needed during compilation which might have temporary variables
;;; replacing the actual production variables

(extend-productions compilation-instan :default-value nil)


;;; Add a new parameter to hold any remapping of duplicate
;;; retrieval-style buffer names from p1->p2 to handle the
;;; proper mapping for instantiation their use in the 
;;; compiled production.

(extend-productions drop-out-buffers-map :default-value nil)

;;; Cache the settings for checking and the compilation trace

(extend-productions valid-1st-p :default-value :unset)
(extend-productions valid-for-compilation :default-value :unset)
(extend-productions invalid-compilation-reason :default-value :unset)
(extend-productions redundant-variables :default-value :unset)

(extend-productions standard-rep)
(extend-productions composition-rep)
(extend-productions standard-rep-sides)


(unsuppress-extension-warnings)

;;; Structure to hold a buffer-type's info instead of
;;; using separate tables.

(defstruct comp-buffer-type name (table (make-hash-table :test 'equalp)) compose 
  map consistency buffers pre-instantiate drop-out whynot-reason)

;;; Globally store the possible composition types in a table
;;; where the key is the name and the value is a comp-buffer-type structure.
;;; The default type is also stored under the key nil.

(defvar *valid-compilation-buffer-types* (make-hash-table :test 'eq))

;;; Also store the reverse lookup of buffer to default type.

(defvar *buffer-to-compilation-type-table* (make-hash-table :test 'eq))

;;; A global lock to protect the global tables.

(defvar *compilation-lock* (bt:make-lock "compilation tables"))



(defstruct compilation-module
  trace
  epl cia rir
  previous
  previous-time
  buffer-var-names
  (buffer-type-table (make-hash-table))
  ppm
  tt
  drop-out-buffers
  no-harvest
  (basic-var-table (make-hash-table :test #'eq))
  (composeable-table (make-hash-table :test #'equalp))
  (signatures-table (make-hash-table :test #'equal))
  (previously-composed-table (make-hash-table :test #'equal))
  (lock (bt:make-recursive-lock "compilation module")))


(defstruct previous-production
  name bindings struct)

(defmacro define-compilation-type (name table buffers mapping compose consistency pre-instantiate drop-out whynot)
  `(define-compilation-type-fct ',name ',table ',buffers ',mapping ',compose ',consistency ',pre-instantiate ',drop-out ',whynot))



(defun define-compilation-type-fct (name table buffers mapping compose consistency pre-instantiate drop-out whynot)
  (cond ((mp-models)
         (print-warning "Cannot create a new compilation type when there are models defined."))       
        
        ((gethash name (bt:with-lock-held (*compilation-lock*) *valid-compilation-buffer-types*))
         (print-warning "~s is already the name of a compilation type.  To redefine it it must first be removed with undefine-compilation-type." name))
        
        ((null name)
         (print-warning "Compilation type must have a non-nil name."))
        
        ((not (symbolp name))
         (print-warning "~s is not a symbol and thus not a valid compilation type name." name))
        
        ((keywordp name)
         (print-warning "A keyword is not valid as a compilation type name."))
        
        ((not (and compose (fctornil compose)))
         (print-warning "A compilation type must specify a compose function."))
        
        ((not (fctornil mapping))
         (print-warning "A compilation type must specify a valid function or nil for mapping."))
        
        ((not (fctornil consistency))
         (print-warning "A compilation type must specify a valid function or nil for consistency."))
        
        ((not (tornil pre-instantiate))
         (print-warning "A compilation type must specify t or nil for pre-instantiate."))
        
        ((not (fctornil whynot))
         (print-warning "A compilation type must specify a valid function or nil for whynot."))
        
        ((not (or (null buffers)
                  (and (listp buffers) (every 'buffer-exists buffers))
                  (eq buffers :default)))
         (print-warning "Buffers must be a list of valid buffer names or the keyword :default"))
        
        ((not (and (listp table)
                   (every (lambda (x) (and (= 3 (length x)) (numberp (first x)) (numberp (second x)) (<= 0 (first x) 63) (<= 0 (second x) 63) (or (eq (third x) t) (fctornil (third x))))) table)))
         (print-warning "Invalid table for buffer type ~s.  All items must be 3 element lists of a p1 index, p2 index, and then either t, nil, or a function." name))
        
        (t
         (let ((type (make-comp-buffer-type :name name :buffers buffers :map mapping :compose compose :consistency consistency :pre-instantiate pre-instantiate :drop-out drop-out :whynot-reason whynot)))
           (bt:with-lock-held (*compilation-lock*) 
             (setf (gethash name *valid-compilation-buffer-types*) type)
           
             ;; default type is also stored under the :default key
           
             (when (eq buffers :default)
               (setf (gethash :default *valid-compilation-buffer-types*) type))
           
             (if (listp buffers)
                 (dolist (x buffers)
                   (setf (gethash x *buffer-to-compilation-type-table*) name))
               (dolist (x (buffers))
                 (unless (gethash x *buffer-to-compilation-type-table*)
                   (setf (gethash x *buffer-to-compilation-type-table*) :default))))
           
             (dolist (x table)
               (setf (gethash (vector (first x) (second x)) (comp-buffer-type-table type)) (third x)))))
         name)))


(defmacro undefine-compilation-type (name)
  `(undefine-compilation-type-fct ',name))

(defun undefine-compilation-type-fct (name)
  (cond ((mp-models)
         (print-warning "Cannot undefine a compilation type when there are models defined."))       
        
        ((null name)
         (print-warning "Must specify the name of a compilation type to undefine."))
        
        ((not (bt:with-lock-held (*compilation-lock*) (gethash name *valid-compilation-buffer-types*)))
         (print-warning "~s is not the name of a compilation type thus it cannot be undefined." name))
        
        (t
         (bt:with-lock-held (*compilation-lock*)
           (remhash name *valid-compilation-buffer-types*)
           
           ;; If it's the default type 
           (when (and (gethash :default *valid-compilation-buffer-types*)
                      (eq (comp-buffer-type-name (gethash :default *valid-compilation-buffer-types*)) name))
             (remhash :default *valid-compilation-buffer-types*)))
         
         ;; don't worry about cleaning up *buffer-to-compilation-type-table* because
         ;; that will be tested later in module reset and appropriate warnings
         ;; can be issued.
         
         name)))


(defun create-composition-module (model-name)
  (declare (ignore model-name))
  
  ;; nothing extra needed now since the types are
  ;; created once when they're defined.
  
  (make-compilation-module))


(defun reset-production-compilation (instance)
  (bt:with-recursive-lock-held ((compilation-module-lock instance))
    (setf (compilation-module-previous instance) nil)
    (setf (compilation-module-previous-time instance) 0)
  
    (clrhash (compilation-module-composeable-table instance))
    (clrhash (compilation-module-buffer-type-table instance))
    (clrhash (compilation-module-basic-var-table instance))
    (clrhash (compilation-module-signatures-table instance))
    (clrhash (compilation-module-previously-composed-table instance))
    
    (setf (compilation-module-buffer-var-names instance) nil)
    (setf (compilation-module-drop-out-buffers instance) nil)
      
    (bt:with-lock-held (*compilation-lock*)
      (dolist (buffer (buffers))
        (let* ((var-name (intern (concatenate 'string "=" (string buffer))))
               (standard (gethash buffer *buffer-to-compilation-type-table*))
               (type (or (and standard (gethash standard *valid-compilation-buffer-types*))
                         (gethash :default *valid-compilation-buffer-types*))))
          
          (push-last var-name (compilation-module-buffer-var-names instance))
          
          (if type
              (progn
                (setf (gethash buffer (compilation-module-buffer-type-table instance)) type)
                (when (comp-buffer-type-drop-out type)
                  (push (cons buffer var-name) (compilation-module-drop-out-buffers instance))))
            (print-warning "No default compilation type available and buffer ~s does not have a type specified." buffer)))))))
  
(defun reset-production-compilation2 (instance)
  (declare (ignore instance))
  (sgp :add-production-hook comp-table))

(defun production-compilation-params (prod param)
  (bt:with-recursive-lock-held ((compilation-module-lock prod))
    (cond ((consp param)
           (case (car param)
             
             (:pct (setf (compilation-module-trace prod) (cdr param)))
             (:tt 
              (setf (compilation-module-tt prod) (safe-seconds->ms (cdr param) 'sgp))
              (cdr param))
             (:cia (setf (compilation-module-cia prod) (cdr param)))
             (:rir (setf (compilation-module-rir prod) (cdr param)))
             (:epl (setf (compilation-module-epl prod) (cdr param)))
             (:ppm (setf (compilation-module-ppm prod) (cdr param)))
             (:do-not-harvest (setf (compilation-module-no-harvest prod) (cdr param)))))
          (t 
           (case param
             (:pct (compilation-module-trace prod))
             (:tt (ms->seconds (compilation-module-tt prod)))
             (:cia (compilation-module-cia prod))
             (:rir (compilation-module-rir prod))
             (:epl (compilation-module-epl prod)))))))


(define-module-fct 'production-compilation
    nil
  (list (define-parameter :ppm :owner nil)
        (define-parameter :do-not-harvest :owner nil)
        (define-parameter :epl :default-value nil 
          :valid-test 'tornil :warning "T or nil"
          :documentation "Enable Production Learning")
        (define-parameter :cia :default-value nil 
          :valid-test 'tornil :warning "T or nil"
          :documentation "Compile Indirect Actions")
        (define-parameter :rir :default-value nil 
          :valid-test 'tornil :warning "T or nil"
          :documentation "Retain indirect retrievals")
        (define-parameter :pct :default-value nil 
          :valid-test 'tornil :warning "T or nil"
          :documentation "Production Compilation Trace")
        
        (define-parameter :tt :default-value 2.0
          :valid-test 'posnum :warning "a positive number"
          :documentation "Threshold time"))
  :version "5.0"
  :documentation "A module that assists the primary procedural module with compiling productions"
  :creation 'create-composition-module
  :reset (list 'reset-production-compilation 'reset-production-compilation2)
  :params 'production-compilation-params)


(defun create-production-signature (production)
  (get-buffer-index production nil)
  (list (production-buffer-indices production)
        (length (production-variables production))
        (length (production-lhs production))
        (length (production-rhs production))))
        

(defun comp-table (production)
  (let ((module (get-module production-compilation)))
    (bt:with-recursive-lock-held ((compilation-module-lock module))
      (push production (gethash (create-production-signature production) (compilation-module-signatures-table module))))))
      
      
(defun compile-productions (production)
  (let ((module (get-module production-compilation))
        (p-name (production-name production)))
    
    (bt:with-recursive-lock-held ((compilation-module-lock module))
      (when (compilation-module-epl module)
        
        (bt:with-recursive-lock-held ((production-lock production))
          
          (when (compilation-module-trace module)
            (model-output "Production Compilation process started for ~s" p-name))
          
          (cond ((not (valid-compilation-production p-name production (compilation-module-cia module) (compilation-module-rir module)))
                 (when (compilation-module-trace module)
                   (model-output "  Production ~s is not valid for compilation" p-name)
                   (model-output "   because ~a" (invalid-compilation-reason p-name production)))
                 (setf (compilation-module-previous module) nil))
                
                ((null (compilation-module-previous module))
                 (when (compilation-module-trace module)
                   (model-output "  No previous production to compose with."))
                 (handle-check-valid-1st-p module p-name production))
                
                (t
                 (let ((p1 (previous-production-struct (compilation-module-previous module))))
                   (bt:with-recursive-lock-held ((production-lock p1))
                     (let* ((retain (and (compilation-module-cia module) (compilation-module-rir module) 
                                         (compute-retain-buffers p1 production)))
                            (p1-s (production-comp-rep p1 (previous-production-bindings (compilation-module-previous module)) (first retain)))
                            (p2-s (production-comp-rep production (production-bindings production) (second retain))))
                       
                       (cond ((> (- (mp-time-ms) (compilation-module-previous-time module))
                                 (compilation-module-tt module))
                              (when (compilation-module-trace module)
                                (model-output "  Cannot compile ~s and ~s because the time between them exceeds the threshold time."
                                              (production-name p1)
                                              p-name))
                              (handle-check-valid-1st-p module p-name production))
                             ((or (stringp p1-s)
                                  (stringp p2-s))
                              (model-output "  Production ~s and ~s cannot be composed~%   because ~a" (production-name p1) p-name 
                                            (if (stringp p1-s) p1-s p2-s))
                              (handle-check-valid-1st-p module p-name production))
                             ((null (composeable-productions-p module p1 p1-s production p2-s))
                              (when (compilation-module-trace module)
                                (model-output "  Production ~s and ~s cannot be composed." (production-name p1) p-name))
                              (handle-check-valid-1st-p module p-name production))
                             (t
                              (when (compilation-module-trace module)
                                (model-output "  Production ~s and ~s are being composed." (production-name p1) p-name)
                                (when (redundant-variable-check (production-name p1) p1)
                                  (model-output "    Production ~s has redundant variables in the conditions which may lead to unusual production compilation results." 
                                                (production-name p1)))
                                (when (redundant-variable-check p-name production)
                                  (model-output "    Production ~s has redundant variables in the conditions which may lead to unusual production compilation results." p-name)))
                              (compose-productions module p1 p1-s production p2-s)
                              (handle-check-valid-1st-p module p-name production)))))))))))))
  

(defun valid-compilation-production (p-name prod allow-indirect rir)
  (let ((v (production-valid-for-compilation p-name)))
    (if (eq :unset v)
        (setf (production-valid-for-compilation p-name)
          (not (or (find 'eval (production-lhs prod) :key 'production-statement-target)
                   (find 'eval (production-rhs prod) :key 'production-statement-target)
                   (find 'bind (production-lhs prod) :key 'production-statement-target)
                   (find 'bind (production-rhs prod) :key 'production-statement-target)
                   (find 'mv-bind (production-lhs prod) :key 'production-statement-target)
                   (find 'mv-bind (production-rhs prod) :key 'production-statement-target)
                   (find #\@ (production-rhs prod) :key 'production-statement-op)
                   
                   (and (null allow-indirect) 
                        ;; if not allowed then any invalidate it
                        (indirect-action-buffer-name (production-rhs prod)))
                   
                   (and allow-indirect 
                        ;; if allowing indirect
                        ;; then reject if any are set using an explicitly
                        ;; bound variable (ignoring retrieval style if rir is set
                        ;; since that will be handled later)
                        (intersection (indirect-action-variables (production-rhs prod) rir)
                                      (production-bind-variables (production-lhs prod) (production-rhs prod))))
                   
                   (slot-modifers-other-than-= (production-lhs prod))
                   (nested-safe-bind-variables (production-lhs prod))
                   (nested-safe-bind-variables (production-rhs prod)))))
      v)))


(defun indirect-action-variables (rhs &optional ignore-retrieval-style)
  (mapcar (lambda (y) (first (production-statement-definition y)))
    (remove-if-not
     (lambda (x) 
       (and (find (production-statement-op x) '(#\= #\* #\+))
            (= (length (production-statement-definition x)) 1)
            (chunk-spec-variable-p (first (production-statement-definition x)))
            (or (null ignore-retrieval-style)
                (and ignore-retrieval-style (not (eq 'retrieval (compilation-buffer-type-fct (production-statement-target x))))))))
       rhs)))
  
(defun production-bind-variables (lhs rhs)
  (let ((binds (append (remove-if-not (lambda (x) (eq (production-statement-target x) 'safe-bind)) lhs)
                       (remove-if-not (lambda (x) (eq (production-statement-target x) 'safe-bind)) rhs))))
    (mapcar (lambda (x) (first (production-statement-definition x))) binds)))

(defun nested-safe-bind-variables (statements)
  (let* ((binds (remove-if-not (lambda (x) (eq (production-statement-target x) 'safe-bind)) statements))
         (bindings (mapcar 'production-statement-definition binds))
         (vars (mapcar 'car bindings))
         (evals (mapcar 'second bindings)))
    (dolist (x vars)
      (when (recursive-find x evals)
        (return-from nested-safe-bind-variables t)))))
    
(defun invalid-compilation-reason (p-name prod)
  (let ((r (production-invalid-compilation-reason p-name)))
    (if (eq :unset r)
        (setf (production-invalid-compilation-reason p-name)
          (cond ((or (find 'eval (production-lhs prod) :key 'production-statement-target)
                     (find 'eval (production-rhs prod) :key 'production-statement-target))
                 "it contains one or more !eval! operators")
                ((or (find 'bind (production-lhs prod) :key 'production-statement-target)
                     (find 'bind (production-rhs prod) :key 'production-statement-target)
                     (find 'mv-bind (production-lhs prod) :key 'production-statement-target)
                     (find 'mv-bind (production-rhs prod) :key 'production-statement-target))
                 "it contains one or more !bind! operators")
                ((find #\@ (production-rhs prod) :key 'production-statement-op)
                 "it contains one or more buffer overwrite actions.")
                ((slot-modifers-other-than-= (production-lhs prod))
                 "it has conditions with modifiers on slot tests")
                ((nested-safe-bind-variables (production-lhs prod))
                 "it has nested safe-bind variables on the LHS")
                ((nested-safe-bind-variables (production-rhs prod))
                 "it has nested safe-bind variables on the RHS")
                ((indirect-action-buffer-name (production-rhs prod))
                 (if (null (get-parameter-value :cia))
                     (format nil "it has an indirect action with the ~a buffer" (indirect-action-buffer-name (production-rhs prod)))
                   (format nil "it has an indirect action using a variable bound with a !safe-bind!")))
                (t 
                 "of an unknown reason. (This should not happen. Please report this issue to Dan.)")))
      r)))


(defun duplicate-buffer-name (op statements)
  (let ((filtered (mapcar 'production-statement-target
                    (remove-if-not (lambda (x) 
                                     (eql op x))
                                   statements :key 'production-statement-op))))
    (car (remove-if-not (lambda (x) (> (count x filtered) 1)) filtered))))


(defun indirect-action-buffer-name (statements)
  (awhen (find-if (lambda (x) 
                    (and (find (production-statement-op x) '(#\= #\* #\+))
                         (= (length (production-statement-definition x)) 1)))
                  statements)
         (production-statement-target it)))

(defun slot-modifers-other-than-= (statements)
  (some (lambda (y)
          (and (production-statement-spec y)
               (find-if-not (lambda (x)
                              (eql x '=))
                            (chunk-spec-slot-spec (production-statement-spec y)) :key 'first)))
        statements))


(defun redundant-variable-check (p-name prod)
  (let ((v (production-redundant-variables p-name)))
    (if (eq :unset v)
        (setf (production-redundant-variables p-name)
          (some (lambda (x)
                  (and (eq #\= (production-statement-op x))
                       (some (lambda (y)
                               (> (count-if 'chunk-spec-variable-p  (chunk-spec-slot-spec (production-statement-spec x) y) :key 'third) 1))
                             (chunk-spec-slots (production-statement-spec x)))))
                (production-lhs prod)))
      v)))


;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - multiple <buffer> actions of the same type for a single buffer of any style
;;;      i.e. there can be at most one modification, one request, and one modification
;;;      request per buffer.

(defun valid-1st-p (p-name prod)
  (let ((v (production-valid-1st-p p-name)))
    (if (eq :unset v)
        (setf (production-valid-1st-p p-name)
          (not (or (find 'stop (production-rhs prod) :key 'production-statement-target)
                   (duplicate-buffer-name #\= (production-rhs prod))
                   (duplicate-buffer-name #\+ (production-rhs prod))
                   (duplicate-buffer-name #\* (production-rhs prod)))))
      v)))


(defun invalid-1st-p-reason (prod)
  (cond ((find 'stop (production-rhs prod) :key 'production-statement-target)
         "it has a !stop! action")
        ((duplicate-buffer-name #\= (production-rhs prod))
         (format nil "it has multiple modification actions for the ~a buffer" (duplicate-buffer-name #\= (production-rhs prod))))
        ((duplicate-buffer-name #\+ (production-rhs prod))
         (format nil "it has multiple requests to the ~a buffer" (duplicate-buffer-name #\+ (production-rhs prod))))
        ((duplicate-buffer-name #\* (production-rhs prod))
         (format nil "it has multiple modification requests to the ~a buffer" (duplicate-buffer-name #\* (production-rhs prod))))
        (t
         "of unknown reason. (This should not happen. Please report this issue to Dan.)")))
 
(defun handle-check-valid-1st-p (module p-name prod)
  (if (valid-1st-p p-name prod)
      (progn
        (setf (compilation-module-previous module)
          (make-previous-production :name p-name
                                    :struct prod
                                    :bindings (copy-tree (production-bindings prod))))
        (setf (compilation-module-previous-time module) (mp-time-ms))
        (when (compilation-module-trace module)
          (model-output "  Setting previous production to ~S." (production-name prod))))
    (progn
      (when (compilation-module-trace module)
        (model-output "  Production ~s is not valid as a first production for compilation" p-name)
        (model-output "   because ~a" (invalid-1st-p-reason prod)))
      (setf (compilation-module-previous module) nil))))


(defun composeable-productions-p (module p1 p1-s p2 p2-s)
  (multiple-value-bind (val exists)
      (gethash (vector (production-name p1) (production-name p2)) (compilation-module-composeable-table module))
    
    (if exists 
        (cond
         ((eq val t)
          t)
         ((listp val)
          (when (compilation-module-trace module)
            (model-output "  Buffer ~S prevents composition of these productions~@[~%   because ~a~]" (first val) (second val))))
         (t
          (print-warning "Invalid value in composeable table -- contact Dan.")))
      (let ((val (determine-composable module p1 p1-s p2 p2-s)))
        (setf (gethash (vector (production-name p1) (production-name p2)) (compilation-module-composeable-table module)) val)
        (if (eq val t) t nil)))))


(defun determine-composable (module p1 p1-s p2 p2-s)
  
  (let ((p1-indices (production-buffer-indices p1))
        (p2-indices (production-buffer-indices p2)))
  
  (dolist (buffer (remove-duplicates (append (production-lhs-buffers p1)
                                             (production-lhs-buffers p2)
                                             (production-rhs-buffers p1)
                                             (production-rhs-buffers p2))))
    
    (let* ((type (gethash buffer (compilation-module-buffer-type-table module)))
           (table (comp-buffer-type-table type))
           (p1-usage (aif (cdr (assoc buffer p1-indices)) it 0))
           (p2-usage (aif (cdr (assoc buffer p2-indices)) it 0))
           (index (vector p1-usage p2-usage))
           (value (gethash index table)))
      
      (unless (and value (or (eq value t) (funcall value buffer module p1 p1-s p1-usage p2 p2-s p2-usage)))
        (let ((reason (awhen (comp-buffer-type-whynot-reason type)
                             (funcall it p1-usage p2-usage value))))
          (when (compilation-module-trace module)
            (model-output "  Buffer ~S prevents composition of these productions~@[~%   because ~a~]" buffer reason))
          (return-from determine-composable (list buffer reason))))))
  
  
  (dolist (buffer (intersection (production-rhs-buffers p1)
                                (production-lhs-buffers p2)) t)
    (let ((type (gethash buffer (compilation-module-buffer-type-table module))))
      (when (comp-buffer-type-consistency type)
        (let ((p1-usage (aif (cdr (assoc buffer p1-indices)) it 0))
              (p2-usage (aif (cdr (assoc buffer p2-indices)) it 0)))
          (unless (funcall (comp-buffer-type-consistency type) buffer module p1 p1-s p1-usage p2 p2-s p2-usage)
            (when (compilation-module-trace module)
              (model-output "  Buffer ~S prevents composition of these productions~%   because the consistency test failed" buffer))
            (return-from determine-composable (list buffer "the consistency test failed"))))))
    
    (let ((bv (intern (concatenate 'string "=" (symbol-name buffer)))))
      (when (and (recursive-find bv (subseq (production-text p2) 1 (position '==> (production-text p2))))
                 (find-if (lambda (x)
                            (and (eq (production-statement-op x) #\+)
                                 (eq (production-statement-target x) buffer)))
                          (production-rhs p1)))
        (let ((reason (format nil "the buffer variable =~s is used in conditions of the second and there is a request in the first production" buffer)))
          
          (when (compilation-module-trace module)
            (model-output "  Buffer ~S prevents composition of these productions~@[~%   because ~a~]" buffer reason))
          (return-from determine-composable (list buffer reason))))))))


;;; Assumes that only = modifiers in the actions and condition 
;;; and checks to see if every condition value matches what was
;;; set in the previous action.

(defun check-consistency (module action action-bindings condition cond-bindings)
  (if (compilation-module-ppm module)
      t
    (let ((action-spec (replace-variables (compose-rep-slots action) action-bindings))
          (cond-spec (replace-variables (compose-rep-slots condition) cond-bindings)))
      (dolist (cond cond-spec t)
        (let ((actions (remove-if-not (lambda (x) 
                                        (eq (spec-slot-name x) (spec-slot-name cond))) action-spec)))
          (when (and actions (notevery (lambda (x)
                                         (chunk-slot-equal (spec-slot-value x) (spec-slot-value cond)))
                                       actions))
            (return-from check-consistency nil)))))))



(defun get-buffer-index (production buffer)
  (unless (production-buffer-indices production)
    (setf (production-buffer-indices production)
      (mapcar (lambda (buffer) (cons buffer 0))
        (sort (remove-duplicates (append (get-buffers (production-lhs production))
                                         (production-rhs-buffers production)))
              'string<)))
    (dolist (x (production-buffer-indices production))
      (when (find (car x) (production-lhs-buffers production))
        (incf (cdr x) 8))
      
      (when (find-if (lambda (y) 
                       (and (eq (production-statement-op y) #\?)
                            (eq (production-statement-target y) (car x))))
                     (production-lhs production))
        (incf (cdr x) 16))
      
      (when (find-if (lambda (y) 
                       (and (eq (production-statement-op y) #\=)
                            (eq (production-statement-target y) (car x))))
                     (production-rhs production))
        (incf (cdr x) 1))
      
      (when (find-if (lambda (y) 
                       (and (eq (production-statement-op y) #\-)
                            (eq (production-statement-target y) (car x))))
                     (production-rhs production))
        (incf (cdr x) 2))
      
      (when (find-if (lambda (y) 
                       (and (eq (production-statement-op y) #\+)
                            (eq (production-statement-target y) (car x))))
                     (production-rhs production))
        (incf (cdr x) 4))
        
      (when (find-if (lambda (y) 
                       (and (eq (production-statement-op y) #\*)
                            (eq (production-statement-target y) (car x))))
                     (production-rhs production))
        (incf (cdr x) 32))))
  
  (aif (cdr (assoc buffer (production-buffer-indices production)))
       it
       0))


(defun get-buffers (items)
  (let ((res nil))
    (dolist (x items res)
      (unless (eq #\! (production-statement-op x))
        (push (production-statement-target x) res)))))

(defun get-compilation-type-struct (buffer module)
  (gethash buffer (compilation-module-buffer-type-table module)))


(defun compose-rep-op (s)
  (caar s))

(defun compose-rep-name (s)
  (second (first s)))

(defun compose-rep-token (s)
  (third (first s)))

(defun compose-rep-slots (s)
  (second s))



(defun instantiate-slot-names (rep bindings)
  (mapcar (lambda (x)
            (if (chunk-spec-variable-p (spec-slot-name x))
                (list (spec-slot-op x) (cdr (assoc (spec-slot-name x) bindings)) (spec-slot-value x))
              x))
    rep))

(defun compose-productions (module p1 p1-s p2 p2-s)
 
  
  (let* ((p1-basic-vars (basic-variables module p1))
         (p2-basic-vars (basic-variables module p2))
         (p2-name (production-name p2))
         (new-bindings nil)
         (p2-bindings (production-bindings p2))
         (p1-indices (production-buffer-indices p1))
         (p2-indices (production-buffer-indices p2))
         (used-buffers (union (mapcar 'car p1-indices)
                              (mapcar 'car p2-indices))))
    
    
    (aif (intersection p1-basic-vars p2-basic-vars)
         (progn
           (multiple-value-setq (p2-s new-bindings) 
             (rename-variables p2-s it (union p1-basic-vars p2-basic-vars)))
           
           (setf (production-compilation-instan p2-name) 
             (replace-variables p2-bindings new-bindings))
           
           (setf (production-drop-out-buffers-map p2-name)
             (remove-if-not (lambda (x) (find x (compilation-module-buffer-var-names module)))
                            new-bindings :key 'car)))
         (progn
           (setf (production-compilation-instan p2-name) p2-bindings)
           (setf (production-drop-out-buffers-map p2-name) nil)))
    
    
    
    ;;; The pre-instantiate step was here ...
    
    
    
    (let* ((mappings nil)
           (ppm (compilation-module-ppm module))
           (bindings (when ppm 
                       (append (previous-production-bindings (compilation-module-previous module))
                               (production-compilation-instan p2-name)))))
      
      (dolist (buffer used-buffers)
        
        (let* ((comp-type (get-compilation-type-struct buffer module))
               (map-fn (comp-buffer-type-map comp-type)))
          
          (when map-fn
            (setf mappings (append (funcall map-fn buffer module p1 p1-s (aif (cdr (assoc buffer p1-indices)) it 0) p2 p2-s (aif (cdr (assoc buffer p2-indices)) it 0)) mappings)))))
      
      
      ;;; Current mechanism for !safe-bind! on the RHS of P1 is to
      ;;; add its binding as a constant value and drop the bind.
      ;;; also add the bindings for all variables used in the bind's evaluation.      
      ;;; Here we add the binding to the mappings
      
      (dolist (x (second p1-s))
        (when (eq (compose-rep-name x) 'safe-bind)
          
          (push-last (assoc (car (compose-rep-slots x)) 
                            (previous-production-bindings (compilation-module-previous module)))
                     mappings)
          (dolist (y (find-variables (cdr (compose-rep-slots x))))
            (push-last (assoc y (previous-production-bindings (compilation-module-previous module)))
                       mappings))))
      
      
      (setf mappings (remove-duplicates mappings))
      (setf mappings (sort mappings #'< :key (lambda (x)
                                               (if (constant-value-p (cdr x) module)
                                                   (if (constant-value-p (car x) module)
                                                       1 
                                                     2)
                                                 0))))
      
      
      (let ((bind-vars (append 
                        (mapcan (lambda (x)
                                  (when (eq '!safe-bind! (third (first x)))
                                    (list (first (second x)))))
                          (first p1-s))
                        (mapcan (lambda (x)
                                  (when (eq '!safe-bind! (third (first x)))
                                    (list (first (second x)))))
                          (first p2-s)))))
                        
        (loop
          (let* ((mapping (pop mappings))
                 (const (and ppm (constant-value-p (cdr mapping) module))))
            (when (null mapping) (return))
            
            (unless (find (car mapping) bind-vars)
              (when const
                (awhen (find (car mapping) bindings :key 'car)
                       (setf mapping it)))
              
              ;; this doesn't replace constants which is a good thing...
                            
              (setf p1-s (replace-variables-special p1-s (list mapping)))
              (setf p2-s (replace-variables-special p2-s (list mapping)))
                            
              (dolist (x mappings)
                (when (eq (car x) (car mapping))
                  (replace mappings (list (cons (cdr mapping) (cdr x))) :start1 (position x mappings :test 'equal))))))))
      
      
      (let ((p3-s (list nil nil)))
        (dolist (buffer used-buffers)
          
          (let* ((comp-type (get-compilation-type-struct buffer module))
                 (compose-fn (comp-buffer-type-compose comp-type)))
          
          (when compose-fn
             (let ((vals (funcall compose-fn buffer module p1 p1-s (aif (cdr (assoc buffer p1-indices)) it 0) p2 p2-s (aif (cdr (assoc buffer p2-indices)) it 0))))
               (setf (first p3-s) (append (first p3-s) (first vals)))
               (setf (second p3-s) (append (second p3-s) (second vals)))))))
        
        
        ;; Copy over anything that isn't a buffer reference
        
        ;; Making sure that the p1 stuff comes before the
        ;; p2 stuff in the new production (since it's being
        ;; pushed it must go backwards)
        
        (dolist (x (first p2-s))
          (when (find (compose-rep-name x) '(safe-eval))
            (push x (first p3-s))))
        
        ;;; need to make sure binds come before evals from the p2 stuff
        ;;; so just do it as a quick and dirty two pass now
        ;;; original order might be nice, but this should handle things
        ;;; for now since that gets munged in the standard rep...
        
        (dolist (x (second p2-s))
          (when (find (compose-rep-name x) '(safe-eval output stop))
            (push x (second p3-s))))
        
        (dolist (x (second p2-s))
          (when (find (compose-rep-name x) '(safe-bind))
            (push x (second p3-s))))
        
        ;;; Don't want duplicate bind conditions which means may need
        ;;; another variable replace pass...
        
        (let ((duplicate-bindings nil)
              (existing-bindings nil)
              expr)
          
          (dolist (x (first p2-s))
            (when (find (compose-rep-name x) '(safe-bind))
              (push x existing-bindings)
              (push x (first p3-s))))
          
          (dolist (x (first p1-s))
            (when (find (compose-rep-name x) '(safe-bind))
              (aif (find (second (compose-rep-slots x)) existing-bindings :test 'equalp :key (lambda (y) (second (compose-rep-slots y))))
                   (push (cons (first (compose-rep-slots x)) (first (compose-rep-slots it))) duplicate-bindings)
                   (push x (first p3-s)))))
          
          (when duplicate-bindings
            (setf p3-s (replace-variables-special p3-s duplicate-bindings)))
          
          ;; These need to respect the duplicate bindings so put them in the loop
          ;; where that's computed and replace them when needed
          
          (dolist (x (first p1-s))
            (when (find (compose-rep-name x) '(safe-eval))
              (if duplicate-bindings
                  (setf expr (replace-variables-for-eval x duplicate-bindings))
                (setf expr x))
              (unless (find expr (first p3-s) :test 'equal) ;; no need for duplicate evals
                (push expr (first p3-s)))))
          
          ;; Here's where we remove the rhs binds from p1 (by only adding the evals and outputs
          ;;  note only duplicate evals are removed not duplicate output because maybe that 
          ;;  output is important and it's only going to show in the trace anyway
          
          (dolist (x (second p1-s))
            (when (find (compose-rep-name x) '(safe-eval output)) 
              (if duplicate-bindings 
                  (setf expr (replace-variables-for-eval x duplicate-bindings))
                (setf expr x))
              (unless (and (eq (compose-rep-name x) 'safe-eval)
                           (find expr (second p3-s) :test 'equal))
                (push expr (second p3-s))))))
        
        ;; Double check that everything gets bound 
        ;; The assumption being that it had to come from the second
        ;; production to get lost (through a retrieval removal or 
        ;; colapsing of conditions).  So, just replace it with
        ;; the instantiated value from p2 if there are any.
        
        (let ((lhs-vars (find-variables (mapcar 'compose-rep-slots (first p3-s)))) ;; must be bound somewhere (what about actions of !safe-bind! ?)
              (rhs-vars (find-variables (mapcar 'compose-rep-slots (second p3-s)))) ;; vars used on RHS includes !safe-bind!
              (rhs-bindings (mapcar (lambda (x) (first (compose-rep-slots x)))  ;; the variable names from the RHS binds
                              (remove 'safe-bind (second p3-s) :test-not 'eq :key 'compose-rep-name))))
          
          (dolist (v rhs-vars)
            (unless (or (find v rhs-bindings)
                        (find v lhs-vars)
                        (find v (compilation-module-buffer-var-names module)))
              (setf (second p3-s) (replace-variables (second p3-s) (list (assoc v (production-compilation-instan p2-name))))))))
        
        (let ((post-conditions nil)
              (new-p nil)
              (dropped-chunks (mapcan (lambda (x)
                                        (let ((buff (find x (compilation-module-drop-out-buffers module) :key 'car)))
                                          (when (and buff
                                                     (numberp (cdr (assoc x (production-buffer-indices p1))))
                                                     (not (zerop (logand (cdr (assoc x (production-buffer-indices p1))) 4))))  ;; require the request bit be set in the first production's usage
                                            (list (cons x
                                                        (aif (chunk-copied-from-fct (cdr (assoc (cdr buff) p2-bindings)))
                                                           it
                                                           (cdr (assoc (cdr buff) p2-bindings))))))))
                                (production-lhs-buffers p2))))
          
          (push (new-production-name) new-p)
          
          
          (push (format nil "~A & ~A~{~@[ - ~a~]~}"
                  (production-name p1) p2-name
                  (mapcar 'cdr (sort dropped-chunks 'string< :key 'car)))
                new-p)
          
          (dolist (condition (if (compilation-module-trace module) (sort-conditions (first p3-s)) (first p3-s))) ;; sort for consistency in pct output
            (if (char= #\! (compose-rep-op condition)) 
                (progn
                  (push (compose-rep-token condition) post-conditions)
                  (push (first (compose-rep-slots condition)) post-conditions)
                  (awhen (second (compose-rep-slots condition))
                    (push it post-conditions)))
              (progn
                (push (compose-rep-token condition) new-p)
                (dolist (test (compose-rep-slots condition))
                  (unless (eq (first test) '=)
                    (push (first test) new-p))
                  (push (second test) new-p)
                  (push (third test) new-p)))))
          
          (when post-conditions
            (setf new-p (append post-conditions new-p)))
          
          (push '==> new-p)
                    
          (dolist (action (if (compilation-module-trace module) (sort-actions (second p3-s)) (second p3-s)))
            
            (push (compose-rep-token action) new-p)
            
            (cond ((find (compose-rep-token action) '(!safe-eval! !output!))
                   (push (first (compose-rep-slots action)) new-p))
                  ((eq (compose-rep-token action) '!safe-bind!)
                   (push (first (compose-rep-slots action)) new-p)
                   (push (second (compose-rep-slots action)) new-p))
                  ((null (compose-rep-slots action))
                   )
                  ((and (= (length (compose-rep-slots action)) 1)
                        (not (listp (first (compose-rep-slots action)))))
                   (push (first (compose-rep-slots action)) new-p))
                  (t
                   (dolist (test (compose-rep-slots action))
                     (unless (eq (first test) '=)
                       (push (first test) new-p))
                     (push (second test) new-p)
                     (push (third test) new-p)))))
          
          
          (let* ((procedural (get-module procedural))
                ;; they should be nil and t, but save just incase to restore afterwards
                ;; of course if delay is nil now it's a problem for compilation...
                (delay (procedural-delay-extra-production-setup procedural))
                (style (procedural-style-check procedural)))
            
            (setf (procedural-delay-extra-production-setup procedural) t)
            (setf (procedural-style-check procedural) nil)
            
            (let* ((new-prod (p-fct (reverse new-p)))
                   (p3 (get-production new-prod)))
              
              (setf (procedural-style-check procedural) style)
              (setf (procedural-delay-extra-production-setup procedural) delay)
              
              (when p3
                (update-params-for-compiled-production p3 new-prod p1 p2 module procedural)))))))))


(defun update-params-for-compiled-production (p3 new-prod p1 p2 module procedural)
  (let ((exists (check-for-duplicate-productions module p3))
        v)
    
    (bt:with-lock-held ((procedural-param-lock procedural))
       (setf v (procedural-v procedural)))
    
    (cond ((null exists)
           ;; New production 
           (when (compilation-module-trace module)
             (model-output "  New production:~%")
             (when v
               (print-production p3 t)))
           
           ;; perform the extra setup since it's good
           
           (add-production-extra-setup p3 procedural)
           
           ;mark it as a compiled productions
           
           (setf (production-user-created new-prod) nil)
           
           ; add it to the quick-look table
           
           (push p3 (gethash (production-documentation p3) (compilation-module-previously-composed-table module)))
           
           ; initialize-stats for new-prod
           
           (initialize-utility-for-compiled-production new-prod (production-name p1) (production-name p2))
           
           (when (and (compilation-module-trace module) v)
             (spp-fct (list new-prod))))
          
          ((null (production-user-created exists))
           
           ;; recreation of a previously compiled
           
           (when (compilation-module-trace module)
             (model-output "  Recreating production ~a" exists))
           
           ;; Since extra setup was not done don't do that in  cleanup either.
           
           (setf (procedural-delay-extra-production-setup procedural) t)
           (delete-production new-prod)
           (setf (procedural-delay-extra-production-setup procedural) nil)
           
           (release-name-fct new-prod)
           
           (update-utility-for-compiled-production exists (production-name p1) (production-name p2))
           
           (when (and (compilation-module-trace module)
                      v)
             (spp-fct (list exists))))
          
          (t 
           ;;recreation of a user production
           
           (when (compilation-module-trace module)
             (model-output "  Result is production ~a~%  No actions taken." exists)) 
           
           ;; Since extra setup was not done don't do that in  cleanup either.

           (setf (procedural-delay-extra-production-setup procedural) t)
           (delete-production new-prod)
           (setf (procedural-delay-extra-production-setup procedural) nil)
           
           (release-name-fct new-prod)))))

(defun new-production-name ()
  (loop (let ((name (new-name production)))
          (unless (get-production name)
            (return name)))))


(defun replace-variables-special (arg bindings)
  (list 
   (mapcar (lambda (x)
             (list (car x)
                   (cond ((eq (compose-rep-name x) 'safe-eval)
                          (replace-variables-for-eval (second x) bindings))
                         ((eq (compose-rep-name x) 'safe-bind)
                          (cons (car (second x)) (replace-variables-for-eval (cdr (second x)) bindings)))
                         (t
                          (replace-variables (second x) bindings)))))
             (first arg))
   (mapcar (lambda (x)
             (list (car x)
                   (cond ((eq (compose-rep-name x) 'safe-eval)
                          (replace-variables-for-eval (second x) bindings))
                         ((eq (compose-rep-name x) 'safe-bind)
                          (cons (car (second x)) (replace-variables-for-eval (cdr (second x)) bindings)))
                         (t
                          (replace-variables (second x) bindings)))))
             (second arg))))



(defun sort-conditions (conditions-list)
  (let ((new-conditions (copy-tree conditions-list)))
    (sort new-conditions 'string< :key (lambda (x)
                                         (if (char= (compose-rep-op x) #\!)
                                             "z"
                                           (compose-rep-token x))))))

(defun sort-actions (actions-list)
  (let ((new-actions (copy-tree actions-list)))
    (stable-sort new-actions 'string> :key 'compose-rep-token)))


(defun check-for-duplicate-productions (module p)
  (bt:with-recursive-lock-held ((production-lock p))
    (let ((previously (gethash (production-documentation p) (compilation-module-previously-composed-table module))))
      (dolist (old-p previously)
        (bt:with-recursive-lock-held ((production-lock old-p))
            (when (equivalent-productions-p module old-p p)
              (return-from check-for-duplicate-productions (production-name old-p)))))
      
      (dolist (old-p (gethash (create-production-signature p) (compilation-module-signatures-table module)) nil)
        ; (unless (find old-p previously) doing the test for each of these is more costly than just failing again on 
        ; the item(s) from the previously-composed-table
        
          (bt:with-recursive-lock-held ((production-lock old-p))
            (when (equivalent-productions-p module old-p p)
              (return-from check-for-duplicate-productions (production-name old-p)))))))) ;)

(defun equivalent-productions-p (module p1 p2)
  (declare (ignorable module))
  (bt:with-recursive-lock-held ((compilation-module-lock module))
    
    (equalp (production-comparison-rep p1)
            (production-comparison-rep p2))))


(defun recursive-find (item list)
  (if (listp list)
      (some (lambda (x) (recursive-find item x)) list)
    (eq item list)))


(defun rename-variables (p vars not-vars)
  (do* ((x vars (cdr x))
        (new-var (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 )
        (bindings (list (cons (car x) new-var))
                  (push (cons (car x) new-var) bindings)))
       ((null (cdr x))
        (values (replace-variables p bindings) bindings))))



(defun basic-variables (module p)
  (multiple-value-bind (value present) (gethash (production-name p) (compilation-module-basic-var-table module))
    (if present
        value
        (setf (gethash (production-name p) (compilation-module-basic-var-table module))
          (set-difference
           (remove-if (lambda (x)
                       (find x (compilation-module-drop-out-buffers module) :key 'cdr))
                      (production-variables p))
           (mapcar (lambda (x) (intern (concatenate 'string "=" (string x)))) (production-lhs-buffers p)))))))


(defun sort-production-slots (a b)
  (if (eq (first a) (first b))
      (if (eq (second a) (second b))
          (let ((va (third a))
                (vb (third b)))
            
            (cond ((symbolp va)
                   (if (symbolp vb)
                       (string< va vb)
                     t))
                  ((stringp va)
                   (if (symbolp vb)
                       nil
                     (if (stringp vb)
                         (string< va vb)
                       t)))
                  ((numberp va)
                   (if (or (symbolp vb) (stringp vb))
                       nil
                     (if (numberp vb)
                         (< va vb)
                       t)))
                  (t ;; anything else for a and b gets compared via their formatted output
                   (if (or (symbolp vb) (stringp vb) (numberp vb))
                       nil
                     (string< (format nil "~s" va) (format nil "~s" vb))))
                  ))
        (string< (second a) (second b)))

    (case (first a)
      (= t)
      (- (case (first b) (= nil) (t t)))
      (< (case (first b) ((= -) nil) (t t)))
      (> (case (first b) ((<= >=) t) (t nil)))
      (<= (case (first b) (>= t) (t nil)))
      (>= nil))))


;; lhs won't have duplicates with action and buffer except ! which get sorted later anyway
;; rhs may have them so sort on the length of slot-value lists and then string of the
;; lists if the same, but will need to do that again at the end since variables will be renamed

(defun sort-production-ops (a b)       
  (if (char-equal (first a) (first b))
      (if (string< (second a) (second b))
          t
        (when (string= (second a) (second b))
          (if (< (length (fourth a)) (length (fourth b)))
              t
            (if (eq (first a) #\!)
                ;; for ! actions  just return nil
                ;; for stability since it doesn't matter
                
                nil
              (when (= (length (third a)) (length (third b)))
                (string< (format nil "~s" (third a))
                         (format nil "~s" (third b))))))))

    (case (first a)
      (#\! t)
      (#\= (case (first b) (#\! nil) (t t)))
      (#\? (case (first b) ((#\! #\=) nil) (t t)))
      (#\+ (case (first b) ((#\! #\= #\?) nil) (t t)))
      (#\* (case (first b) ((#\- #\@) t) (t nil)))
      (#\- (case (first b) (#\@ t) (t nil)))
      (#\@ nil))))


(defun production-comparison-rep (production)
  (aif (production-standard-rep (production-name production))
       it
       (produce-standard-representation production)))

(defun production-comp-rep (production bindings retain-indirect-retrievals)
  (aif (production-composition-rep (production-name production))
       it
       (produce-composition-representation production bindings retain-indirect-retrievals)))


(defun produce-standard-representation (production) ;; Only works for composeable productions -- no mv-binds and no nested bind variables
  (let ((indirect nil)
        (lhs nil)
        (rhs nil)
        (name (production-name production))
        (lhs-bind-vars nil)
        (lhs-slot-vars nil)
        (renamed nil)
        (buffer-vars nil))
    
    (aif (production-standard-rep-sides name)
         (setf lhs (first it) rhs (second it))
         (progn
           (setf lhs (stable-sort (mapcar (lambda (x)
                                            (list (production-statement-op x)
                                                  (production-statement-target x)
                                                  (if (char= #\! (production-statement-op x))
                                                      (production-statement-definition x)
                                                    (awhen (production-statement-spec x)
                                                           (stable-sort (chunk-spec-slot-spec it) 'sort-production-slots)))))
                                    (production-lhs production))
                                  'sort-production-ops))
           (setf rhs (stable-sort (mapcar (lambda (x)
                                            (list (production-statement-op x)
                                                  (production-statement-target x)
                                                  (if (char= #\! (production-statement-op x))
                                                      (production-statement-definition x)
                                                    (if (= (length (production-statement-definition x)) 1)
                                                        (progn
                                                          (setf indirect t)
                                                          (production-statement-definition x))
                                                      (awhen (production-statement-spec x)
                                                             (stable-sort (chunk-spec-slot-spec it) 'sort-production-slots))))))
                                    (production-rhs production))
                                  'sort-production-ops))
           (setf (production-standard-rep-sides name) (list lhs rhs indirect))))
    
    (dolist (x lhs)
      (when (char= #\= (first x))
          (pushnew (intern (string-upcase (concatenate 'string "=" (symbol-name (second x))))) buffer-vars)))
    
    (dolist (c lhs)
      (when (and (char= (car c) #\!) (find (second c) '(bind safe-bind)))
        (push (first (third c)) lhs-bind-vars))
      (when (char= (car c) #\=)
        (dolist (x (third c))
          (when (and (eq (first x) '=) (chunk-spec-variable-p (third x)) (not (find (third x) lhs-bind-vars))
                     (not (find (third x) lhs-slot-vars :key 'car)) (not (find (third x) buffer-vars)))
            (push (list (third x) (second c) (second x)) lhs-slot-vars)))))
    
    (dolist (x lhs-slot-vars)
      (let ((new-name (intern (string-upcase (concatenate 'string "=" (symbol-name (second x)) "-&-" (symbol-name (third x)))))))
        (push (cons (first x) new-name) renamed)))
    
    (setf lhs (replace-variables lhs renamed))
    (setf rhs (replace-variables rhs renamed))
    
    ;; handle LHS !bind! and !safe-bind! actions (ignore mv-bind and assume not nested)
    
    (let ((bindings nil)
          (other-bang-actions nil))
      
      (dolist (c lhs)
        (when (char= (car c) #\!) 
          (setf lhs (remove c lhs))
          (if (find (second c) '(bind safe-bind))
              (push c bindings)
            (push c other-bang-actions))))
      
      (setf bindings (sort bindings 'string< :key (lambda (x) (format nil "~s" (cdr (third x))))))
      
      (setf renamed nil)
      
      (let ((c 0))
        (dolist (x bindings)
          (let ((new-name (intern (string-upcase (concatenate 'string "=lhs-bind-var-" (princ-to-string c))))))
            (push (cons (first (third x)) new-name) renamed)
            (setf (first (third x)) new-name)
            (incf c))))
      
      (setf lhs (replace-variables lhs renamed))
      (setf rhs (replace-variables rhs renamed))
      (setf other-bang-actions (sort (replace-variables other-bang-actions renamed) 'string< :key (lambda (x) (format nil "~s" (third x)))))
      (setf lhs (append lhs bindings other-bang-actions)))
    
    ;; Now the RHS
    
    (let ((bindings nil)
          (other-bang-actions nil))
      
      (dolist (c rhs)
        (when (char= (car c) #\!) 
          (setf rhs (remove c rhs))
          (if (find (second c) '(bind safe-bind))
              (push c bindings)
            (push c other-bang-actions))))
      
      (setf bindings (sort bindings 'string< :key (lambda (x) (format nil "~s" (cdr (third x))))))
      
      (setf renamed nil)
      
      (let ((c 0))
        (dolist (x bindings)
          (let ((new-name (intern (string-upcase (concatenate 'string "=rhs-bind-var-" (princ-to-string c))))))
            (push (cons (first (third x)) new-name) renamed)
            (setf (first (third x)) new-name)
            (incf c))))
      
      (setf rhs (replace-variables rhs renamed))
      (setf other-bang-actions (sort (replace-variables other-bang-actions renamed) 'string< :key (lambda (x) (format nil "~s" (third x)))))
      (setf rhs (append (stable-sort rhs 'sort-production-ops) bindings other-bang-actions)))      
    
    (setf (production-standard-rep name) (list lhs rhs))))


(defun compute-retain-buffers (p1 p2)
  (let ((retain (list nil nil))
        (buffers (remove-duplicates (append (copy-list (production-rhs-buffers p1))
                                            (copy-list (production-rhs-buffers p2))))))
    
    
    (dolist (x buffers)
      
      (when (eq 'retrieval (compilation-buffer-type-fct x))
        (case (cdr (assoc x (production-buffer-indices p2)))
          ((4 12 20 28) ;; second has a request so the second is retained
           
           (push x (second retain)))
          ((8 24) ; second tests buffer so first needs to be instantiated if has one
           )
          (t ;; retain the first if it has one
           (case (cdr (assoc x (production-buffer-indices p1)))
             ((4 12 20 28) ; first has a request
              (push x (first retain))))))))
    retain))


;;; When cia is on we need to instantiate the indirect actions, except
;;; when rir is also on and it's a retrieval style buffer.

(defun produce-composition-representation (production bindings retain-indirect-requests) 
  (let ((indirect nil)
        (indirect-vars nil)
        (lhs nil)
        (rhs nil)
        (name (production-name production))
        (compose-rep nil)
        (bind-vars nil))
    
    (aif (production-standard-rep-sides name)
         (setf lhs (first it) rhs (second it) indirect (third it) bind-vars (fourth it))
         (progn
           (setf lhs (stable-sort (mapcar (lambda (x)
                                            (list (production-statement-op x)
                                                  (production-statement-target x)
                                                  (if (char= #\! (production-statement-op x))
                                                      (progn
                                                        (when (eq (production-statement-target x) 'safe-bind)
                                                          (push (car (production-statement-definition x)) bind-vars))
                                                        (production-statement-definition x))
                                                    (awhen (production-statement-spec x)
                                                           (stable-sort (chunk-spec-slot-spec it) 'sort-production-slots)))))
                                    (production-lhs production))
                                  'sort-production-ops))
           (setf rhs (stable-sort (mapcar (lambda (x)
                                            (list (production-statement-op x)
                                                  (production-statement-target x)
                                                  (if (char= #\! (production-statement-op x))
                                                      (production-statement-definition x)
                                                    (if (= (length (production-statement-definition x)) 1)
                                                        (progn
                                                          (setf indirect t)
                                                          (production-statement-definition x))
                                                      (awhen (production-statement-spec x)
                                                             (stable-sort (chunk-spec-slot-spec it) 'sort-production-slots))))))
                                    (production-rhs production))
                                  'sort-production-ops))
           (setf (production-standard-rep-sides name) (list lhs rhs indirect bind-vars))))
    
    
    (setf compose-rep (list (mapcar (lambda (x)
                                      (list (list 
                                             (first x)
                                             (second x)
                                             (case (first x)
                                               (#\! (intern (string-upcase (concatenate 'string "!" (symbol-name (second x)) "!"))))
                                               (#\? (intern (string-upcase (concatenate 'string "?" (symbol-name (second x)) ">"))))
                                               (#\= (intern (string-upcase (concatenate 'string "=" (symbol-name (second x)) ">"))))))
                                            (third x)))
                              lhs)
                            (mapcar (lambda (x)
                                      (list (list (first x)
                                                  (second x)
                                                  (case (first x)
                                                    (#\! (intern (string-upcase (concatenate 'string "!" (symbol-name (second x)) "!"))))
                                                    (t (intern (string-upcase (concatenate 'string (princ-to-string (first x)) (symbol-name (second x)) ">"))))))
                                            (if (and (not (eq (first x) #\!))
                                                     (third x)
                                                     (= (length (third x)) 1)
                                                     (atom (first (third x)))
                                                     (not (find (second x) retain-indirect-requests))
                                                     )
                                                
                                                (if (and (chunk-spec-variable-p (first (third x)))
                                                         (find (first (third x)) bind-vars))
                                                    (return-from produce-composition-representation  
                                                      (format nil "an indirect request with buffer ~s uses a variable from a LHS !safe-bind!" (second x)))
                                                  (let ((c (aif (and (chunk-spec-variable-p (first (third x)))
                                                                     (cdr (assoc (first (third x)) bindings)))
                                                                (progn
                                                                  (push (first (third x)) indirect-vars)
                                                                  it)
                                                                (first (third x)))))
                                                    (if (not (chunk-p-fct c))
                                                        (return-from produce-composition-representation  
                                                          (format nil "an indirect action uses value ~s which is not a chunk" c))
                                                      (mapcar (lambda (y)
                                                                (list '= y (chunk-slot-value-fct c y)))
                                                        (chunk-filled-slots-list-fct c t))))
                                                  )
                                              
                                              (if (and (eq (first x) #\+)
                                                       (third x)
                                                       (= (length (third x)) 1)
                                                       (atom (first (third x)))
                                                       (not (find (second x) retain-indirect-requests))
                                                       (chunk-spec-variable-p (first (third x)))
                                                       (find (first (third x)) bind-vars))
                                                  (return-from produce-composition-representation
                                                    (format nil "an indirect request with buffer ~s uses a variable from a LHS !safe-bind!" (second x)))
                                                (third x)))))
                              rhs)))
    
    (if indirect
        (dolist (v indirect-vars)
          (setf compose-rep (replace-variables-special compose-rep (list (assoc v bindings)))))
      (setf (production-composition-rep name) compose-rep))
    compose-rep))


(defun buffer+-union (a1 a2 bindings)
  (let* ((a2-slots (mapcar 'spec-slot-name (compose-rep-slots a2)))
         (a2-no-dynamic (mapcar (lambda (x) (if (chunk-spec-variable-p x) 
                                                (cdr (assoc x bindings))
                                              x))
                          a2-slots))
    
         (a1-remain (remove-if (lambda (x)
                                 (and (eq (spec-slot-op x) '=)
                                      
                                      (or
                                       (find (spec-slot-name x) a2-slots) ;; matches could be static or dynamic
                                       (find (spec-slot-name x) a2-no-dynamic)
                                       (and (chunk-spec-variable-p (spec-slot-name x))
                                            ;; the instantiated slot value matches something in the instantiated p2 slots
                                            (find (cdr (assoc (spec-slot-name x) bindings)) a2-no-dynamic)))))
                               (compose-rep-slots a1))))
    (list (first a1) (append a1-remain (compose-rep-slots a2))))) ;; should this remove-duplicates ?

  

(defun buffer=-union (a1 a2 bindings) ;; same as above now since + and = are represented the same
  (buffer+-union a1 a2 bindings))


(defun buffer-condition-union (c1 c2 a1 bindings) ;; c1 + (c2-a1)
  (when (or c1 c2)
    (if (null c2)
        c1
      (let* ((a1-slots (replace-variables (mapcar 'spec-slot-name (compose-rep-slots a1)) bindings))
             
             (c2-remain (remove-if (lambda (x)
                                     (aif (cdr (assoc (spec-slot-name x) bindings)) ;; if it's a variable use the binding
                                          (find it a1-slots)
                                          (find (spec-slot-name x) a1-slots)))
                                   (compose-rep-slots c2))))
        (if (null c1)
            (list (first c2) c2-remain)
          (list (first c1) (remove-duplicates (append (compose-rep-slots c1) c2-remain) :test 'equal)))))))


(defun constant-value-p (val module)
  (or (not (chunk-spec-variable-p val))
      (find val (compilation-module-buffer-var-names module))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; User commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro specify-compilation-buffer-type (buffer-name buffer-type)
  `(specify-compilation-buffer-type-fct ',buffer-name ',buffer-type))

(defun specify-compilation-buffer-type-fct (buffer-name buffer-type)
  (let ((module (get-module production-compilation)))
    (if module
        (bt:with-recursive-lock-held ((compilation-module-lock module))
          (let ((type (bt:with-lock-held (*compilation-lock*) (gethash buffer-type *valid-compilation-buffer-types*))))
            (cond ((not (= (mp-time-ms) 0))
                   (print-warning "Cannot change a buffer's compilation type once the model has started running."))
                  ((not (find buffer-name (buffers)))
                   (print-warning "No buffer named ~s found." buffer-name))
                  ((not type)
                   (print-warning "Invalid compilation buffer type ~S." buffer-type))
                  (t
                   (setf (gethash buffer-name (compilation-module-buffer-type-table module)) type)
                   t))))
      (print-warning "No production compilation module found"))))

(defun external-specify-compilation-buffer-type (buffer-name buffer-type)
  (specify-compilation-buffer-type-fct (string->name buffer-name) (string->name buffer-type)))


(defun show-compilation-buffer-types ()
  (let ((module (get-module production-compilation)))
    (if module
        (bt:with-recursive-lock-held ((compilation-module-lock module))
          (let ((len (apply 'max (mapcar (lambda (x)
                                           (length (string x)))
                                   (buffers)))))
            (command-output "  ~va        Type" len "Buffer")
            (maphash (lambda (buffer type)
                       (command-output "~va        ~a" len buffer (comp-buffer-type-name type)))
                     (compilation-module-buffer-type-table module))))
      (print-warning "No production compilation module found"))))


(defmacro compilation-buffer-type (buffer-name)
  `(compilation-buffer-type-fct ',buffer-name))

(defun compilation-buffer-type-fct (buffer)
  (let ((module (get-module production-compilation)))
    (if module
        (bt:with-recursive-lock-held ((compilation-module-lock module))
          (let ((type (gethash buffer (compilation-module-buffer-type-table module))))
            (if type
                (comp-buffer-type-name type)
              nil)))
      (print-warning "No production compilation module found"))))

(defun external-compilation-buffer-type (buffer)
  (compilation-buffer-type-fct (string->name buffer)))

(add-act-r-command "show-compilation-buffer-types" 'show-compilation-buffer-types "Output all the buffer compilation type assignments for production compilation. No params.")
(add-act-r-command "compilation-buffer-type" 'external-compilation-buffer-type "Return the production compilation type assignment for a buffer. Params: buffer-name.")
(add-act-r-command "specify-compilation-buffer-type" 'external-specify-compilation-buffer-type "Set the production compilation type assignment for a buffer. Params: buffer-name compilation-type.")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Support code for converting the excel tables into files in the tools
;;; directory.
;;; Call this with a list of pathnames to tab delimited files of valid spreadsheets 
;;; that describe the types of buffer for composition to create.
;;;
;;; It will write out a file in the tools directory named {type-name}-compilation.lisp
;;; where {type-name} is the name specified for the type in the spreadsheet description.
;;;
;;; It also writes out empty definitions for the functions that need to be defined
;;; based on the specification given.
;;;
;;; For now those control functions will be passed low-level data types which aren't
;;; specified anywhere (the raw production structures, ugly list based production
;;; parses, and the compilation module instance).  Eventually, these interface functions
;;; will need to be passed something more appropriate and specified, but right now
;;; it's just a more distributed version of the current code.


(defun build-compilation-type-file (files &optional (by-dan nil))
  (dolist (file files)
    ; Since this isn't a user function it forgoes a lot of error checking
    (with-open-file (f file :direction :input)
      
      (let* (map compose consistency pre-instan buffers table drop-out whynot
              (style (read f))
              (pathname (translate-logical-pathname (format nil "ACT-R:tools;~(~a~)-compilation.lisp" style))))
        
        (with-open-file (outfile pathname :direction :output :if-exists :overwrite :if-does-not-exist :create)
        
        (multiple-value-bind (second minute hour date month year) (decode-universal-time (get-universal-time))
          (declare (ignore hour minute second))
          
          (format outfile ";;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Author      : ~[Dan Bothell~]~%" by-dan)
          (format outfile ";;; Copyright   : (c) ~d ~[Dan Bothell~]~%" year by-dan)
          (format outfile ";;; Availability: Covered by the GNU LGPL, see LGPL.txt~%")
          (format outfile ";;; Address     : ~[Department of Psychology~]~%" by-dan)
          (format outfile ";;;             : ~[Carnegie Mellon University~]~%" by-dan)
          (format outfile ";;;             : ~[Pittsburgh, PA 15213-3890~]~%" by-dan)
          (format outfile ";;;             : ~[db30@andrew.cmu.edu~]~%" by-dan)
          (format outfile ";;; ~%")
          (format outfile ";;; ~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Filename    : ~(~a~)-compilation.lisp~%" style)
          (format outfile ";;; Version     : 1.0~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Description : Production compilation ~s style definition.~%" style)
          (format outfile ";;; ~%")
          (format outfile ";;; Bugs        : ~%")
          (format outfile ";;;~%")
          (format outfile ";;; To do       : ~%;;;~%")
          (format outfile ";;; ----- History -----~%")
          (format outfile ";;;~%")
          (format outfile ";;; ~d.~d.~2,'0d ~[Dan~]~%" year month date by-dan)
          (format outfile ";;;             : * Created automatically by build-compilation-type-file.~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile "~%")
          (format outfile "#+:packaged-actr (in-package :act-r)~%")
          (format outfile "#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)~%")
          (format outfile "#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)~%")

          (setf map (read f))
          (setf compose (read f))
          (setf consistency (read f))
          (setf pre-instan (read f))
          (setf drop-out (read f))
          (setf whynot (read f))
          (setf buffers (read f))
          ;; get the rest of the empty line
          (read-line f)
          ;; read the line P1 and P2
          (read-line f)
          (let ((p2-indices 
                 (do* ((l nil)
                       (s (make-string-input-stream (read-line f)))
                       (val (read s nil nil) (read s nil nil)))
                      ((null val) (reverse l))
                   (push val l))))
            (read-line f)
            (dotimes (i (length p2-indices))
              (let ((p1-index (read f)))
                (read f)
                (dotimes (j (length p2-indices))
                  (awhen (read f)
                         (push (list p1-index (nth j p2-indices) it) table))))))
          
          (format outfile "~%")
          (format outfile "~%")
          
          ;; Write out the stubs for the functions specified
          (when map
            (format outfile "(defun ~a (buffer module p1 p1-s p1-index p2 p2-s p2-index)~%)~%" map))
          (when compose 
            (format outfile "(defun ~a (buffer module p1 p1-s p1-index p2 p2-s p2-index)~%)~%" compose))
          (when consistency 
            (format outfile "(defun ~a (buffer module p1 p1-s p1-index p2 p2-s p2-index)~%)~%" consistency))
          (when pre-instan 
            (format outfile "(defun ~a (buffer module p1 p1-s p1-index p2 p2-s p2-index)~%)~%" pre-instan))
          (when whynot 
            (format outfile "(defun ~a (p1-index p2-index failed-function)~%)~%" whynot))
          
          ;; write stubs for any functions in the table
          
          (let (done)
            (dolist (x table)
              (when (and (third x) (not (eq (third x) t)) (not (find (third x) done)))
                (format outfile "(defun ~a (buffer module p1 p1-s p1-index p2 p2-s p2-index)~%)~%" (third x))
                (push (third x) done))))
          
          ;; Write the buffer definition itself
          
          (format outfile "~%(define-compilation-type ~a ~a ~s ~a ~a ~a ~a ~a ~a)~%~%"
            style table buffers map compose consistency pre-instan drop-out whynot)
          
          (format outfile "#|~%")
          (format outfile "This library is free software; you can redistribute it and/or~%")
          (format outfile "modify it under the terms of the GNU Lesser General Public~%")
          (format outfile "License as published by the Free Software Foundation; either~%")
          (format outfile "version 2.1 of the License, or (at your option) any later version.~%")
          (format outfile "~%")
          (format outfile "This library is distributed in the hope that it will be useful,~%")
          (format outfile "but WITHOUT ANY WARRANTY; without even the implied warranty of~%")
          (format outfile "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU~%")
          (format outfile "Lesser General Public License for more details.~%")
          (format outfile "~%")
          (format outfile "You should have received a copy of the GNU Lesser General Public~%")
          (format outfile "License along with this library; if not, write to the Free Software~%")
          (format outfile "Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA~%")
          (format outfile "|#~%")))))))


#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
              
